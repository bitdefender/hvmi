/*
 * Copyright (c) 2020 Bitdefender
 * SPDX-License-Identifier: Apache-2.0
 */
///
/// @file   intro_types.h
///
/// @brief  Exposes the types and constants used by various Introcore APIs defined
/// in glueiface.h
///
/// These are used to describe Introcore options, alerts, and other
/// events that may be generated by an introspected guest.
///
/// @ingroup group_public_headers
///

#ifndef _INTRO_TYPES_H_
#define _INTRO_TYPES_H_

#include "env.h"

// Allow integrators to ignore the following typedefs if the following types are already defined
#ifndef INTROCORE_NOCOMPAT

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#ifndef TRUE
#define TRUE                    true
#endif

#ifndef FALSE
#define FALSE                   false
#endif

typedef uint8_t                 UINT8, *PUINT8;
typedef uint16_t                UINT16, *PUINT16;
typedef uint32_t                UINT32, *PUINT32;
typedef unsigned long long      UINT64, *PUINT64;

typedef int8_t                  INT8, *PINT8;
typedef int16_t                 INT16, *PINT16;
typedef int32_t                 INT32, *PINT32;
typedef long long               INT64, *PINT64;

typedef uint8_t                 BYTE, *PBYTE;
typedef uint16_t                WORD, *PWORD;
typedef uint32_t                DWORD, *PDWORD;

// If we don't define 64-bit types to `long long`, we have a problem with string formatting, since
// `%lx` should be used on gnu, and `%llx` on MSVC
typedef unsigned long long      QWORD, *PQWORD;

typedef unsigned char           UCHAR, *PUCHAR;
typedef char                    CHAR, *PCHAR;

typedef _Bool                   BOOLEAN;

typedef size_t                  SIZE_T;

#ifndef INT_COMPILER_MSVC
typedef uint16_t                WCHAR, *PWCHAR;
#include "intro_sal.h"
#else
typedef uint16_t                WCHAR, *PWCHAR;
typedef int64_t                 ssize_t;
#endif // !INT_COMPILER_MSVC

#endif // !INTROCORE_NOCOMPAT


#pragma pack(push, 8)


// Introspection alerts

///
/// @brief  Event classes
///
typedef enum _INTRO_EVENT_TYPE
{
    /// Sent when an EPT violation triggers an alert. See #EVENT_EPT_VIOLATION.
    introEventEptViolation = 1,
    /// Sent when a MSR violation triggers an alert.See #EVENT_MSR_VIOLATION.
    introEventMsrViolation,
    /// Sent when a CR violation triggers an alert. See #EVENT_CR_VIOLATION.
    introEventCrViolation,
    /// Sent when a CR violation triggers an alert. See #EVENT_XCR_VIOLATION.
    introEventXcrViolation,
    /// Sent for integrity violation alerts. See #EVENT_INTEGRITY_VIOLATION.
    introEventIntegrityViolation,
    /// Sent for virtual address translation alerts. See #EVENT_TRANSLATION_VIOLATION.
    introEventTranslationViolation,
    /// Sent for code/data injection alerts. See #EVENT_MEMCOPY_VIOLATION.
    introEventInjectionViolation,
    /// Sent when a DTR violation triggers an alert. See #EVENT_DTR_VIOLATION.
    introEventDtrViolation,
    /// Plain text message sent from Introcore to the integrator. See #EVENT_INTROSPECTION_MESSAGE.
    introEventMessage,
    /// Informational event sent when a process is created or terminated by the guest. See #EVENT_PROCESS_EVENT.
    introEventProcessEvent,
    /// Informational event sent when the remediation tool is injected or terminated. See #EVENT_AGENT_EVENT.
    introEventAgentEvent,
    /// Informational event sent when kernel module is loaded or when a module is loaded inside a protected process.
    /// See #EVENT_MODULE_EVENT.
    introEventModuleEvent,
    /// Informational event sent when the guest crashes. See #EVENT_CRASH_EVENT.
    introEventCrashEvent,
    /// Informational event sent when a hardware exception is triggered by a guest process. See #EVENT_EXCEPTION_EVENT.
    introEventExceptionEvent,
    /// Informational event containing the connections opened by a process. See #EVENT_CONNECTION_EVENT.
    introEventConnectionEvent,
    /// Sent for unauthorized process creation alerts. See #EVENT_PROCESS_CREATION_VIOLATION.
    introEventProcessCreationViolation,
    /// Sent for suspicious module loads alerts. See #EVENT_MODULE_LOAD_VIOLATION.
    introEventModuleLoadViolation,
    /// Sent for third party engines detections. See #EVENT_ENGINES_DETECTION_VIOLATION.
    introEventEnginesDetectionViolation
} INTRO_EVENT_TYPE;


///
/// @brief  Scan engine alert types
///
typedef enum _INTRO_ENG_NOTIFICATION_TYPE
{
    /// @brief  Execution attempt result.
    ///
    /// The result is of type #ENG_NOTIFICATION_CODE_EXEC.
    introEngineNotificationCodeExecution = 1,
    /// @brief  Command line scan results.
    ///
    /// The result is of type #ENG_NOTIFICATION_CMD_LINE.
    introEngineNotificationCmdLine
} INTRO_ENG_NOTIF_TYPE;


///
/// @brief  Event actions
///
/// Priority of the action increases as its value increases (introGuestAllowed has
/// the lowest priority, while introGuestRetry has the highest priority).
///
typedef enum _INTRO_ACTION
{
    /// The guest was allowed to perform the operation leading to the event. The guest used got real values
    /// (the guest state was modified).
    introGuestAllowed = 0,

    /// The guest was allowed to perform the operation leading to the event, but the operation was performed using
    /// virtual - i.e. Hypervisor maintained shadow values.
    introGuestAllowedVirtual,

    /// The guest is allowed to do the desired action, but with the artificial supplied data.
    ///
    /// For example, when trying to conceal something inside the guest memory.
    introGuestAllowedPatched,

    /// The guest was not allowed to perform the operation leading to the event (the operation was skipped in the host
    /// the guest state was not modified).
    ///
    /// For example, modifying the LSTAR MSR is not allowed.
    introGuestNotAllowed,

    /// The action was ignored and allowed.
    introGuestIgnore,

    /// Retry the execution of the very same instruction.
    ///
    /// This is used when the violated GVA gets swapped out. In that case, we will simply retry execution of the
    /// instruction until it remains swapped in.
    introGuestRetry,
} INTRO_ACTION;


///
/// @brief  The reason for which an INTRO_ACTION was taken
///
typedef enum _INTRO_ACTION_REASON
{
    /// The action was not allowed because there was no reason to allow it.
    introReasonAllowed = 0,
    /// The action was allowed, but it has the BETA flag (Introcore is in log-only mode).
    introReasonAllowedFeedback,
    /// The action was blocked because no exception signature matched.
    introReasonSignatureNotMatched,
    /// The action was blocked because there was no exception for it.
    introReasonNoException,
    /// The exception (and signature, where's the case) matched, but the extra checks failed.
    introReasonExtraChecksFailed,
    /// The exception file was not loaded (there are no exceptions).
    introReasonExceptionsNotLoaded,
    /// An internal error occurred (no memory, pages not present, etc.).
    introReasonInternalError,
    /// A valid exception was found, but the action was blocked because the value code signature did not match the one
    /// from the exception.
    introReasonValueCodeNotMatched,
    /// A valid exception was found, but the action was blocked because the value signature did not match the one from
    /// the exception.
    introReasonValueNotMatched,
    /// A valid exception was found, but the action was blocked because the modified export did not match the one from
    /// the exception.
    introReasonExportNotMatched,
    /// A valid exception was found, but the action was blocked because the modified IDT entry did not match the one
    /// from the exception.
    introReasonIdtNotMatched,
    /// A valid exception was found, but the action was blocked because the OS version did not match the one from the
    /// exception.
    introReasonVersionOsNotMatched,
    /// A valid exception was found, but the action was blocked because the Introcore version did not match the one
    /// from the exception.
    introReasonVersionIntroNotMatched,
    /// A valid exception was found, but the action was blocked because the process-creation flags did not match the
    /// ones from the exception.
    introReasonProcessCreationNotMatched,
    /// The action was allowed because the OldValue is the same as the NewValue (in the WriteInfo structure) - caused
    /// by events such as calls to ProbeForWrite.
    introReasonSameValue,

    /// Not a valid reason.
    ///
    /// Must always be the last value defined.
    introReasonUnknown
} INTRO_ACTION_REASON;


///
/// @brief  The type of the object protected by an EPT hook.
///
typedef enum _INTRO_OBJECT_TYPE
{
    introObjectTypeRaw = 1,                         ///< Raw hook.
    introObjectTypeInternal,                        ///< Internal kernel structures - they don't generate alerts.
    introObjectTypeSsdt,                            ///< SSDT (Windows only).
    introObjectTypeFastIoDispatch,                  ///< Fast IO Dispatch (Windows only).
    introObjectTypeDriverObject,                    ///< Driver object.
    introObjectTypeKmModule,                        ///< Kernel module (ntoskrnl.exe, hal.dll, etc.).
    introObjectTypeIdt,                             ///< IDT.
    introObjectTypeGdt,                             ///< GDT.
    introObjectTypeKmUnpack,                        ///< Kernel unpacker.
    introObjectTypeProcess,                         ///< User process.
    introObjectTypeUmInternal,                      ///< Internal user-mode structure.
    introObjectTypeUmUnpack,                        ///< User-mode unpacker.
    introObjectTypeUmHeap,                          ///< User-mode heap.
    introObjectTypeUmStack,                         ///< User-mode stack.
    introObjectTypeUmGenericNxZone,                 ///< User-mode non executable zone.
    introObjectTypeUmModule,                        ///< User-mode library.
    introObjectTypeDetourRead,                      ///< Hooked page against PG reads.
    introObjectTypeTokenPtr,                        ///< Access Token pointer.
    introObjectTypeCreds = introObjectTypeTokenPtr, ///< Access 'struct creds' fields.
    introObjectTypeHalDispatchTable,                ///< Hal dispatch table.
    introObjectTypeHalIntController,                ///< Hal interrupt controller.
    introObjectTypeSelfMapEntry,                    ///< Self mapping index in PDBR.
    introObjectTypeHalHeap,                         ///< Hal heap.
    introObjectTypeVdso,                            ///< Virtual dynamic shared object (user-mode, Linux-only).
    introObjectTypeVsyscall,                        ///< Virtual SYSCALL (user-mode, Linux-only).
    introObjectTypeExTable,                         ///< Exception Table (Linux-only).
    introObjectTypeVeAgent,                         ///< The Virtualization exception agent injected inside the guest.
    introObjectTypeIdtr,                            ///< IDTR.
    introObjectTypeGdtr,                            ///< GDTR.
    introObjectTypeProcessCreation,                 ///< Process creation violation.
    introObjectTypeExecSuspiciousDll,               ///< Executions in suspicious DLL loads.
    introObjectTypeKmLoggerContext,                 ///< Infinity hook modifications of WMI_LOGGER_CONTEXT.GetCpuClock.
    introObjectTypeProcessCreationDpi,              ///< Process creation violation DPI.
    introObjectTypeTokenPrivs,                      ///< Token privileges.
    introObjectTypeSudExec,                         ///< Executions inside the SharedUserData region.
    introObjectTypeHalPerfCounter,                  ///< Write protection over HalPerformanceCounter.
    introObjectTypeHookedFunction,                  ///< The function is already hooked.
    introObjectTypeSlackSpace,                      ///< The slack space is not 0-filled/NOP-filled.
    introObjectTypeSecDesc,                         ///< Process security descriptor pointer.
    introObjectTypeAcl,                             ///< Process ACL (SACL/DACL) was modified.
    introObjectTypeSudIntegrity,                    ///< Integrity protection of SharedUserData region.
    introObjectTypeInterruptObject,                 ///< An interrupt object from KPRCB.

    introObjectTypeTest,

    //
    // If you need to add fields here, please consider how it interacts with other parts of Introcore
    // (below are just a few examples):
    // - EVENT_EPT_VIOLATION.Originator.Module and EVENT_EPT_VIOLATION.Originator.Module.ReturnModule
    //      - Should they be valid or invalid ?
    //      - If they are invalid, why ?
    //
    // - EVENT_EPT_VIOLATION.Victim.Module and EVENT_EPT_VIOLATION.Victim.Module.DriverObject:
    //      - Should they be valid or invalid ?
    //      - Must you add another structure in the Victim union ?
    //      - Should the integrator use a generic name based on the new type ?
    //
    // - Other alerts & fields, if that's the case
    //
} INTRO_OBJECT_TYPE;


///
/// @brief  Address family.
///
typedef enum _INTRO_NET_AF
{
    introNetAfIpv4 = 0, ///< IPv4.
    introNetAfIpv6,     ///< IPv6.

    introNetAfUnknown   ///< Unknown.
} INTRO_NET_AF;


///
/// @brief  Connection states.
///
typedef enum _INTRO_NET_STATE
{
    introNetStateEstablished = 0,
    introNetStateSynSent,
    introNetStateSynRecv,
    introNetStateFinWait,
    introNetStateFinWait2,
    introNetStateTimeWait,
    introNetStateClosed,
    introNetStateCloseWait,
    introNetStateLastAck,
    introNetStateListening,
    introNetStateClosing,
    introNetStateNewSynRecv,        ///< Available only on Linux.
    introNetStateDeleteTcb,         ///< Available only on Windows.

    introNetStateUnknown
} INTRO_NET_STATE;


//
// These masks are used to configure what protection policies should be applied per process
//

///
/// @defgroup   group_process_options Process protection options
/// @brief      Options used to configure what protection policies should be applied per process.
/// @ingroup    group_public
/// @{
///

/// No protection policy. The process is not protected.
#define PROC_OPT_NONE                               0x00000000
/// Blocks hooks being set on core user-mode DLLs.
#define PROC_OPT_PROT_CORE_HOOKS                    0x00000004
/// @brief  Identifies unpacking/decryption attempts in the main executable.
#define PROC_OPT_PROT_UNPACK                        0x00000008
/// Blocks foreign write inside the target process.
#define PROC_OPT_PROT_WRITE_MEM                     0x00000010
/// @brief  Blocks hooks being set on Wininet user-mode DLLs (Windows only).
#define PROC_OPT_PROT_WSOCK_HOOKS                   0x00000020
/// Blocks malicious execution attempts.
#define PROC_OPT_PROT_EXPLOIT                       0x00000040
/// Blocks thread hijacking attempts inside the target process (Windows only).
#define PROC_OPT_PROT_SET_THREAD_CTX                0x00000080
/// Blocks thread hijacking attempts inside the target process (Linux only).
#define PROC_OPT_PROT_PTRACE                        0x00000080
/// Blocks APC queuing inside the target process (Windows only).
#define PROC_OPT_PROT_QUEUE_APC                     0x00000100
/// Prevent the process from creating child processes (other than instances of itself).
#define PROC_OPT_PROT_PREVENT_CHILD_CREATION        0x00000200
/// Blocks double agent attacks (malicious DLL loading) (Windows only).
#define PROC_OPT_PROT_DOUBLE_AGENT                  0x00000400
/// @brief  Uses third party engines to scan the command line of a process.
#define PROC_OPT_PROT_SCAN_CMD_LINE                 0x00000800
/// Blocks foreing processes from setting instrumentation callbacks inside the target process (Windows only).
#define PROC_OPT_PROT_INSTRUMENT                    0x00001000

/// Any event inside the process will trigger the injection of the remediation tool.
#define PROC_OPT_REMEDIATE                          0x20000000
/// The process will be killed if an exploit is detected.
///
/// Without this flag, if a process is protected with #PROC_OPT_PROT_EXPLOIT, the instruction that generated the
/// alert will be skipped, but the next instruction might generate a new alert and so on.
#define PROC_OPT_KILL_ON_EXPLOIT                    0x40000000
/// Process is monitored, but in log-only mode so no actions will be blocked.
#define PROC_OPT_BETA                               0x80000000

/// Aggregates all the flags that will generate #introEventInjectionViolation events.
#define PROC_OPT_PROT_INJECTION            (PROC_OPT_PROT_WRITE_MEM         |\
                                            PROC_OPT_PROT_SET_THREAD_CTX    |\
                                            PROC_OPT_PROT_PTRACE            |\
                                            PROC_OPT_PROT_QUEUE_APC         |\
                                            PROC_OPT_PROT_DOUBLE_AGENT      |\
                                            PROC_OPT_PROT_INSTRUMENT)

/// Aggregates all the process protection flags.
#define PROC_OPT_PROT_ALL                  (PROC_OPT_PROT_CORE_HOOKS                |\
                                            PROC_OPT_PROT_INJECTION                 |\
                                            PROC_OPT_PROT_WSOCK_HOOKS               |\
                                            PROC_OPT_PROT_EXPLOIT                   |\
                                            PROC_OPT_PROT_PREVENT_CHILD_CREATION    |\
                                            PROC_OPT_PROT_SCAN_CMD_LINE             |\
                                            PROC_OPT_KILL_ON_EXPLOIT)

/// @}

//
// Granular protection flags.
//

///
/// @defgroup   group_options Activation and protection flags
/// @brief      Options used to control Introcore behavior
/// @ingroup    group_public
/// @{


#define INTRO_OPT_PROT_KM_NT                0x0000000000000001ull   ///< Enable kernel image protection (Windows only).
#define INTRO_OPT_PROT_KM_LX                0x0000000000000001ull   ///< Enable kernel image protection (Linux only).
#define INTRO_OPT_PROT_KM_HAL               0x0000000000000002ull   ///< Enable HAL protection (Windows only).
#define INTRO_OPT_PROT_KM_SSDT              0x0000000000000004ull   ///< Enable SSDT protection (Windows only).
#define INTRO_OPT_PROT_KM_IDT               0x0000000000000008ull   ///< Enable IDT protection.
    /// @brief  Enable HDT (Hal Dispatch Table) protection (Windows only).
#define INTRO_OPT_PROT_KM_HAL_DISP_TABLE    0x0000000000000010ull
#define INTRO_OPT_PROT_KM_SYSTEM_CR3        0x0000000000000020ull   ///< Enable System process PDBR protection.
#define INTRO_OPT_PROT_KM_TOKEN_PTR         0x0000000000000040ull   ///< Enable process token protection (Windows only).
#define INTRO_OPT_PROT_KM_CREDS             0x0000000000000040ull   ///< Enable 'struct creds' protection (Linux only).
/// @brief  Enable core NT drivers protection (Windows only).
#define INTRO_OPT_PROT_KM_NT_DRIVERS        0x0000000000000080ull
/// @brief  Enable Linux kernel modules protection (Linux only).
#define INTRO_OPT_PROT_KM_LX_MODULES        0x0000000000000080ull
#define INTRO_OPT_PROT_KM_AV_DRIVERS        0x0000000000000100ull   ///< Enable AV drivers protection (Windows only).
#define INTRO_OPT_PROT_KM_XEN_DRIVERS       0x0000000000000200ull   ///< Enable Xen drivers protection (Windows only).
/// @brief  Enable driver object & fast I/O dispatch protection.
#define INTRO_OPT_PROT_KM_DRVOBJ            0x0000000000000400ull
#define INTRO_OPT_PROT_KM_CR4               0x0000000000000800ull   ///< Enable CR4.SMEP and CR4.SMAP protection.
#define INTRO_OPT_PROT_KM_MSR_SYSCALL       0x0000000000001000ull   ///< Enable SYSCALL/SYSENTER MSR protection.
/// @brief  Enable interrupt descriptor-table registers protection.
#define INTRO_OPT_PROT_KM_IDTR              0x0000000000002000ull
/// @brief  Enable execution prevention on the Hal Heap when it is not ASLR'd (Windows only).
#define INTRO_OPT_PROT_KM_HAL_HEAP_EXEC     0x0000000000004000ull
/// @brief  Enable Hal Interrupt Controller write protection.
#define INTRO_OPT_PROT_KM_HAL_INT_CTRL      0x0000000000008000ull

#define INTRO_OPT_PROT_UM_MISC_PROCS        0x0000000000010000ull   ///< Enable user-mode process protection.
/// @brief  Enable user-mode system processes protection (injection only).
#define INTRO_OPT_PROT_UM_SYS_PROCS         0x0000000000020000ull
#define INTRO_OPT_PROT_KM_SELF_MAP_ENTRY    0x0000000000040000ull   ///< Enable self-map entry protection.
/// @brief  Enable global descriptor-table registers protection.
#define INTRO_OPT_PROT_KM_GDTR              0x0000000000080000ull

/// @brief  Enable process creation and termination events (generates #introEventProcessEvent events).
#define INTRO_OPT_EVENT_PROCESSES           0x0000000000100000ull
/// @brief  Enable user mode and kernel mode module load and unload events (generates introEventModuleEvent events).
#define INTRO_OPT_EVENT_MODULES             0x0000000000200000ull
/// @brief  Enable OS crash events (generates introEventCrashEvent events).
#define INTRO_OPT_EVENT_OS_CRASH            0x0000000000400000ull
/// @brief  Enable application crash events (generates #introEventExceptionEvent).
#define INTRO_OPT_EVENT_PROCESS_CRASH       0x0000000000800000ull

#define INTRO_OPT_AGENT_INJECTION           0x0000000001000000ull   ///< Enable agent injections.

/// @brief  Enable full-path protection of processes.
///
/// If set, the full path of the main module of the process must match the full path provided at protection time.
#define INTRO_OPT_FULL_PATH                 0x0000000002000000ull
#define INTRO_OPT_KM_BETA_DETECTIONS        0x0000000004000000ull   ///< Enable kernel beta (log only) detections.
/// @brief  Send suspicious pages to be scanned by third party scan engines.
#define INTRO_OPT_NOTIFY_ENGINES            0x0000000008000000ull
/// @brief  Enable in-guest page-table filtering (64-bit Windows only).
#define INTRO_OPT_IN_GUEST_PT_FILTER        0x0000000010000000ull

/// @brief  Enable memory cleanup after an OS crash (Windows).
///
/// When this flag is set, introcore will try to remove all the code it modified inside the guest.
#define INTRO_OPT_BUGCHECK_CLEANUP          0x0000000020000000ull
/// @brief  Enable memory cleanup after an OS crash (Linux).
///
/// When this flag is set, introcore will try to remove all the code it modified inside the guest.
#define INTRO_OPT_PANIC_CLEANUP             0x0000000020000000ull
/// @brief  Enable system processes beta (log only) detection
#define INTRO_OPT_SYSPROC_BETA_DETECTIONS   0x0000000040000000ull

/// @brief  Enable the Virtualization exception page table access pre-filtering agent (64-bit Windows only).
#define INTRO_OPT_VE                        0x0000000080000000ull

/// @brief  Enable connection events.
///
/// Ignored for processes that do not have the #PROC_OPT_PROT_EXPLOIT protection flag.
/// Will send one #introEventConnectionEvent for each connection opened by a process
/// when an #introEventEptViolation event is triggered for an execution attempt.
#define INTRO_OPT_EVENT_CONNECTIONS         0x0000000100000000ull

/// @brief  Enable protection on WMI_LOGGER_CONTEXT.GetCpuClock used by InfinityHook (Windows only).
#define INTRO_OPT_PROT_KM_LOGGER_CONTEXT    0x0000000200000000ull

/// @brief  Enable process creation protection for child processes created with debug flag.
#define INTRO_OPT_PROT_DPI_DEBUG            0x0000000400000000ull
/// @brief  Enable process creation protection for pivoted stack.
#define INTRO_OPT_PROT_DPI_STACK_PIVOT      0x0000000800000000ull
/// @brief  Enable process creation protection for stolen token.
#define INTRO_OPT_PROT_DPI_TOKEN_STEAL      0x0000001000000000ull
/// @brief  Enable process creation protection for heap sprayed parent.
#define INTRO_OPT_PROT_DPI_HEAP_SPRAY       0x0000002000000000ull

/// @brief  Enable kernel EAT read protection (Windows only).
#define INTRO_OPT_PROT_KM_NT_EAT_READS      0x0000004000000000ull
/// @brief  Enable kernel '_text' section read protection (Linux only).
#define INTRO_OPT_PROT_KM_LX_TEXT_READS     0x0000008000000000ull
#define INTRO_OPT_PROT_KM_VDSO              0x0000010000000000ull   ///< Enable vDSO image protection (Linux only).

#define INTRO_OPT_PROT_KM_SWAPGS            0x0000020000000000ull   ///< Enable SWAPGS (CVE-2019-1125) mitigation.

/// @brief  Enable protection over Token Privileges bitmaps.
#define INTRO_OPT_PROT_KM_TOKEN_PRIVS       0x0000040000000000ull
/// @brief  Enable process creation protection for parent which has violated Token privileges constraints.
#define INTRO_OPT_PROT_DPI_TOKEN_PRIVS      0x0000080000000000ull
/// @brief  Examines the code where the current thread started execution when the current thread creates a process.
#define INTRO_OPT_PROT_DPI_THREAD_SHELL     0x0000100000000000ull

/// @brief  Enable protection against executions on SharedUserData.
///
/// Note that even if the alert can be both for KM or UM, it is a KM policy flag, since there
/// could not be SharedUserData executions without malicious behavior happening in kernel.
#define INTRO_OPT_PROT_KM_SUD_EXEC          0x0000200000000000ull

/// @brief  Enable protection over HalPerformanceCounter's function pointer, which is called inside
///         KeQueryPerformanceCounter.
#define INTRO_OPT_PROT_KM_HAL_PERF_CNT      0x0000400000000000ull

/// @brief  Enable integrity protection over the Security Descriptor pointer and the 2 ACLs (SACL/DACL).
#define INTRO_OPT_PROT_KM_SD_ACL            0x0000800000000000ull
/// @brief  Enable detection of Security Descriptor pointer modifications and ACL modifications on process creation
#define INTRO_OPT_PROT_DPI_SD_ACL           0x0001000000000000ull

/// @brief  Enable integrity checks over various SharedUserData fields, as well as the zero-filled zone after the
///         SharedUserData structure.
#define INTRO_OPT_PROT_KM_SUD_INTEGRITY     0x0002000000000000ull

/// @brief  Enable protection against modifications of interrupt objects from KPRCB's InterruptObject.
#define INTRO_OPT_PROT_KM_INTERRUPT_OBJ     0x0004000000000000ull

/// Aggregates all the deep process inspection flags.
#define INTRO_OPT_PROT_DPI                  (INTRO_OPT_PROT_DPI_DEBUG       | \
                                            INTRO_OPT_PROT_DPI_STACK_PIVOT  | \
                                            INTRO_OPT_PROT_DPI_TOKEN_STEAL  | \
                                            INTRO_OPT_PROT_DPI_HEAP_SPRAY   | \
                                            INTRO_OPT_PROT_DPI_TOKEN_PRIVS  | \
                                            INTRO_OPT_PROT_DPI_THREAD_SHELL | \
                                            INTRO_OPT_PROT_DPI_SD_ACL)


/// Aggregates all the kernel mode protection flags.
#define INTRO_OPT_ENABLE_KM_PROTECTION      (INTRO_OPT_PROT_KM_NT           | \
                                            INTRO_OPT_PROT_KM_LX            | \
                                            INTRO_OPT_PROT_KM_HAL           | \
                                            INTRO_OPT_PROT_KM_SSDT          | \
                                            INTRO_OPT_PROT_KM_VDSO          | \
                                            INTRO_OPT_PROT_KM_NT_DRIVERS    | \
                                            INTRO_OPT_PROT_KM_LX_MODULES    | \
                                            INTRO_OPT_PROT_KM_NT_EAT_READS  | \
                                            INTRO_OPT_PROT_KM_DRVOBJ        | \
                                            INTRO_OPT_PROT_KM_HAL_HEAP_EXEC | \
                                            INTRO_OPT_PROT_KM_HAL_INT_CTRL  | \
                                            INTRO_OPT_PROT_KM_SELF_MAP_ENTRY| \
                                            INTRO_OPT_PROT_KM_SWAPGS        | \
                                            INTRO_OPT_PROT_KM_SUD_EXEC      | \
                                            INTRO_OPT_PROT_KM_HAL_PERF_CNT)

/// Aggregates all the user mode protection flags.
#define INTRO_OPT_ENABLE_UM_PROTECTION      (INTRO_OPT_PROT_UM_MISC_PROCS   | \
                                            INTRO_OPT_PROT_UM_SYS_PROCS     | \
                                            INTRO_OPT_PROT_DPI)

/// Aggregates all the AV protection flags.
#define INTRO_OPT_ENABLE_AV_PROTECTION      (INTRO_OPT_PROT_KM_AV_DRIVERS)

/// Aggregates all the control register protection flags.
#define INTRO_OPT_ENABLE_CR_PROTECTION      (INTRO_OPT_PROT_KM_CR4)

/// Aggregates all the MSR protection flags.
#define INTRO_OPT_ENABLE_MSR_PROTECTION     (INTRO_OPT_PROT_KM_MSR_SYSCALL)

/// Aggregates all the integrity protection flags.
#define INTRO_OPT_ENABLE_INTEGRITY_CHECKS   (INTRO_OPT_PROT_KM_IDT              | \
                                            INTRO_OPT_PROT_KM_HAL_DISP_TABLE    | \
                                            INTRO_OPT_PROT_KM_SYSTEM_CR3        | \
                                            INTRO_OPT_PROT_KM_TOKEN_PTR         | \
                                            INTRO_OPT_PROT_KM_CREDS             | \
                                            INTRO_OPT_PROT_KM_LOGGER_CONTEXT    | \
                                            INTRO_OPT_PROT_KM_TOKEN_PRIVS       | \
                                            INTRO_OPT_PROT_KM_SD_ACL            | \
                                            INTRO_OPT_PROT_KM_SUD_INTEGRITY     | \
                                            INTRO_OPT_PROT_KM_INTERRUPT_OBJ)

/// Aggregates all the descriptor table register protection flags.
#define INTRO_OPT_ENABLE_DTR_PROTECTION     (INTRO_OPT_PROT_KM_IDTR | \
                                            INTRO_OPT_PROT_KM_GDTR)

/// Aggregates all the kernel log-only detection flags.
#define INTRO_OPT_ENABLE_KM_BETA_DETECTIONS (INTRO_OPT_KM_BETA_DETECTIONS)

/// Aggregates all the full path protection flags.
#define INTRO_OPT_ENABLE_FULL_PATH          (INTRO_OPT_FULL_PATH)

/// Aggregates all the XEN-related protection flags.
#define INTRO_OPT_ENABLE_XEN_PROTECTION     (INTRO_OPT_PROT_KM_XEN_DRIVERS)

/// Aggregates all the agent injection flags.
#define INTRO_OPT_ENABLE_MANUAL_AGENT_INJ   (INTRO_OPT_AGENT_INJECTION)

/// Aggregates all the miscellaneous protection flags.
#define INTRO_OPT_ENABLE_MISC_EVENTS        (INTRO_OPT_EVENT_PROCESSES  | \
                                            INTRO_OPT_EVENT_MODULES     | \
                                            INTRO_OPT_EVENT_OS_CRASH    | \
                                            INTRO_OPT_EVENT_PROCESS_CRASH)

/// All the flags that can be modified without unloading Introcore.
#define INTRO_OPT_DYNAMIC_OPTIONS_MASK      (0xffffffffffffffff)

/// Aggregates all the default options.
#define INTRO_OPT_DEFAULT_OPTIONS           (INTRO_OPT_ENABLE_KM_PROTECTION         |\
                                             INTRO_OPT_ENABLE_UM_PROTECTION         |\
                                             INTRO_OPT_ENABLE_AV_PROTECTION         |\
                                             INTRO_OPT_ENABLE_XEN_PROTECTION        |\
                                             INTRO_OPT_ENABLE_CR_PROTECTION         |\
                                             INTRO_OPT_ENABLE_MSR_PROTECTION        |\
                                             INTRO_OPT_ENABLE_DTR_PROTECTION        |\
                                             INTRO_OPT_ENABLE_KM_BETA_DETECTIONS    |\
                                             INTRO_OPT_ENABLE_INTEGRITY_CHECKS      |\
                                             INTRO_OPT_ENABLE_FULL_PATH             |\
                                             INTRO_OPT_IN_GUEST_PT_FILTER)

/// Aggregates all the default XEN options.
#define INTRO_OPT_DEFAULT_XEN_OPTIONS       (INTRO_OPT_ENABLE_KM_PROTECTION         |\
                                             INTRO_OPT_ENABLE_UM_PROTECTION         |\
                                             INTRO_OPT_ENABLE_AV_PROTECTION         |\
                                             INTRO_OPT_ENABLE_XEN_PROTECTION        |\
                                             INTRO_OPT_ENABLE_CR_PROTECTION         |\
                                             INTRO_OPT_ENABLE_MSR_PROTECTION        |\
                                             INTRO_OPT_ENABLE_DTR_PROTECTION        |\
                                             INTRO_OPT_ENABLE_INTEGRITY_CHECKS      |\
                                             INTRO_OPT_ENABLE_FULL_PATH             |\
                                             INTRO_OPT_ENABLE_MANUAL_AGENT_INJ      |\
                                             INTRO_OPT_ENABLE_MISC_EVENTS           |\
                                             INTRO_OPT_IN_GUEST_PT_FILTER)

/// Aggregates all the kernel-only protection and activation flags.
#define INTRO_OPT_ONLY_KERNEL               (INTRO_OPT_ENABLE_KM_PROTECTION         |\
                                             INTRO_OPT_ENABLE_AV_PROTECTION         |\
                                             INTRO_OPT_ENABLE_XEN_PROTECTION        |\
                                             INTRO_OPT_ENABLE_MSR_PROTECTION        |\
                                             INTRO_OPT_ENABLE_DTR_PROTECTION        |\
                                             INTRO_OPT_ENABLE_KM_BETA_DETECTIONS    |\
                                             INTRO_OPT_ENABLE_INTEGRITY_CHECKS      |\
                                             INTRO_OPT_ENABLE_FULL_PATH             |\
                                             INTRO_OPT_IN_GUEST_PT_FILTER)

/// Aggregates all the flags that are affected by the INTRO_OPT_ENABLE_KM_BETA_DETECTIONS flag.
#define POLICY_KM_BETA_FLAGS                                                                                        \
    (INTRO_OPT_PROT_KM_NT | INTRO_OPT_PROT_KM_HAL | INTRO_OPT_PROT_KM_SSDT | INTRO_OPT_PROT_KM_IDT                  \
     | INTRO_OPT_PROT_KM_HAL_DISP_TABLE | INTRO_OPT_PROT_KM_SYSTEM_CR3 | INTRO_OPT_PROT_KM_TOKEN_PTR                \
     | INTRO_OPT_PROT_KM_NT_DRIVERS | INTRO_OPT_PROT_KM_AV_DRIVERS | INTRO_OPT_PROT_KM_XEN_DRIVERS                  \
     | INTRO_OPT_PROT_KM_DRVOBJ | INTRO_OPT_PROT_KM_CR4 | INTRO_OPT_PROT_KM_MSR_SYSCALL | INTRO_OPT_PROT_KM_IDTR    \
     | INTRO_OPT_PROT_KM_HAL_HEAP_EXEC | INTRO_OPT_PROT_KM_HAL_INT_CTRL | INTRO_OPT_PROT_KM_SELF_MAP_ENTRY          \
     | INTRO_OPT_PROT_KM_GDTR | INTRO_OPT_PROT_KM_LX | INTRO_OPT_PROT_KM_VDSO | INTRO_OPT_PROT_KM_LX_MODULES        \
     | INTRO_OPT_PROT_KM_CREDS | INTRO_OPT_PROT_KM_TOKEN_PRIVS | INTRO_OPT_PROT_KM_SUD_EXEC                         \
     | INTRO_OPT_PROT_KM_LOGGER_CONTEXT | INTRO_OPT_PROT_KM_NT_EAT_READS | INTRO_OPT_PROT_KM_HAL_PERF_CNT           \
     | INTRO_OPT_PROT_KM_SD_ACL | INTRO_OPT_PROT_KM_SUD_INTEGRITY | INTRO_OPT_PROT_KM_INTERRUPT_OBJ)


/// @}

///
/// @defgroup   group_alert_flags Alert flags
/// @brief      Flags used to describe an alert
/// @ingroup    group_public
/// @{
///

#define ALERT_FLAG_BETA                 0x0000000000000001  ///< If set, the alert is a BETA alert. No action was taken.
#define ALERT_FLAG_ANTIVIRUS            0x0000000000000002  ///< If set, the alert is on anti virus object.
#define ALERT_FLAG_SYSPROC              0x0000000000000004  ///< If set, the alert is on system process.
#define ALERT_FLAG_NOT_RING0            0x0000000000000008  ///< If set, the alert was triggered in ring 1, 2 or 3.
#define ALERT_FLAG_ASYNC                0x0000000000000010  ///< If set, the alert was generated in an async manner.
#define ALERT_FLAG_LINUX                0x0000000000000020  ///< If set, the alert was generated by a Linux guest.
/// @brief  If set, the alert was generated due to a third party scan engines detection.
#define ALERT_FLAG_FROM_ENGINES         0x0000000000000040

/// @brief  If set, the alert is a feedback only alert.
///
/// No action was taken, the user should not be notified, but the event should generate feedback.
#define ALERT_FLAG_FEEDBACK_ONLY        0x0000000000000080
#define ALERT_FLAG_DEP_VIOLATION        0x0000000000000100  ///< If set, the alert was generated by a DEP violation.
#define ALERT_FLAG_PROTECTED_VIEW       0x0000000000000200  ///< If set, the alert was generated in a protected EPT.
/// @brief If set, the alert was generated by a kernel to user mode violation.
#define ALERT_FLAG_KM_UM                0x0000000000000400

/// @}

//
// Misc size definitions.
//

#define ALERT_PATH_MAX_LEN              260u    ///< The maximum size of a path inside an alert structure.
#define ALERT_IMAGE_NAME_LEN            16u     ///< The maximum size of a name inside an alert structure.
/// @brief  The maximum size of an Introcore message inside #EVENT_INTROSPECTION_MESSAGE.
#define ALERT_MAX_MESSAGE_SIZE          256u
#define ALERT_MAX_INSTRUX_LEN           128u    ///< The maximum size of an instruction inside an alert structure.
/// @brief  The maximum size of an executable section name inside an alert structure
#define ALERT_MAX_SECTION_NAME_LEN      8u
#define ALERT_MAX_FUNCTIONS             4u      ///< The maximum number of functions included in an alert structure.
#define ALERT_MAX_FUNCTION_NAME_LEN     32u     ///< The maximum size of a function name inside an alert structure.
#define ALERT_MAX_INJ_DUMP_SIZE         512u    ///< The maximum size of an injection buffer inside an alert structure.
#define ALERT_MAX_CODEBLOCKS            64u     ///< The maximum number of code blocks included in an alert structure.
#define ALERT_CMDLINE_MAX_LEN           512u    ///< The maximum size of a command line included in an alert structure.
#define ALERT_EXCEPTION_SIZE            255u    ///< The maximum size of an exception included in an alert structure.
/// @brief  The maximum size of a detection name as given by a third party scan engine.
#define ALERT_MAX_DETECTION_NAME        128u
#define ALERT_MAX_ENGINES_VERSION       32u     ///< The maximum size of the third party scan engines version.

 /// @brief      The size of the buffers in which we store the security descriptors. The security descriptor is composed
 /// by its 2 Access Control Lists (SACL/DACL) and their corresponding Access Control Entries. Below there is an
 /// example of the memory map for the security descriptor dumped in winsecdesc.c. Although the size is only 0x6C,
 /// we want to have some room left for processes with more ACEs.
 ///
 /// 0x00   ///////////////////////////////
 ///        ///   SECURITY_DESCRIPTOR   ///
 ///        ///////////////////////////////
 /// 0x14   ///////////////////////////////         |
 ///        ///      SACL Header        ///         | 
 ///        ///  AclRev=2  AclSize=0x1C-///---------| Total SACL size 0x1C
 ///        ///      AceCount=1         ///         |
 ///        ///////////////////////////////         |
 /// 0x1C   ///////////////////////////////         |
 ///        ///         ACE[0]          ///         |
 ///        ///////////////////////////////         |
 /// 0x30   ///////////////////////////////    |      
 ///        ///      DACL Header        ///    |
 ///        ///  AclRev=2  AclSize=0x3C-///----|
 ///        ///      AceCount=2         ///    |
 ///        ///////////////////////////////    |  Total DACL size 0x3C
 /// 0x38   ///////////////////////////////    |
 ///        ///         ACE[0]          ///    |
 ///        ///////////////////////////////    |
 ///        ///////////////////////////////    |
 ///        ///         ACE[1]          ///    |
 ///        ///////////////////////////////    |
 /// 0x6C
#define INTRO_SECURITY_DESCRIPTOR_SIZE    1024u

/// @brief  Printable name used for #introObjectTypeCreds objects.
#define VICTIM_PROCESS_CREDENTIALS          u"Process Credentials"
/// @brief  Printable name used for #introObjectTypeDriverObject objects.
#define VICTIM_DRIVER_OBJECT                u"Driver Object"
/// @brief  Printable name used for #introObjectTypeHalDispatchTable objects.
#define VICTIM_HAL_DISPATCH_TABLE           u"HalDispatchTable"
/// @brief  Printable name used for #introObjectTypeIdt.
#define VICTIM_IDT                          u"IDT"
/// @brief  Printable name used for #introObjectTypeKmLoggerContext objects.
#define VICTIM_CIRCULAR_KERNEL_CTX_LOGGER   u"Circular Kernel Context Logger"
/// @brief  Printable name used for #introObjectTypeTokenPtr objects.
#define VICTIM_PROCESS_TOKEN                u"Process Token"
/// @brief  Printable name used for #introObjectTypeTokenPrivs objects.
#define VICTIM_TOKEN_PRIVILEGES             u"Token privileges"
/// @brief  Printable name used for #introObjectTypeHalPerfCounter objects.
#define VICTIM_HAL_PERFORMANCE_COUNTER      u"HalPerformanceCounter"
/// @brief  Printable name used for #introObjectTypeSecDesc objects.
#define VICTIM_PROCESS_SECURITY_DESCRIPTOR  u"Security Descriptor"
/// @brief  Printable name used for #introObjectTypeAcl objects.
#define VICTIM_PROCESS_ACL                  u"Access Control List"
/// @brief  Printable name used for #introObjectTypeInterruptObject.
#define VICTIM_INTERRUPT_OBJECT             u"Interrupt Object"

///
/// @brief  EPT access types.
///
typedef enum
{
    INTRO_EPT_NONE = 0, ///< No access.
    INTRO_EPT_READ,     ///< Read access.
    INTRO_EPT_WRITE,    ///< Write access.
    INTRO_EPT_EXECUTE,  ///< Execute access.
} INTRO_EPT_ACCESS_TYPE;


///
/// @brief  MSR access types.
///
typedef enum
{
    INTRO_MSR_READ = 1, ///< Read access.
    INTRO_MSR_WRITE = 2,///< Write access.
} INTRO_MSR_ACCESS_TYPE;


/// @brief  Violation header version.
#define INTRO_VIOLATION_VERSION         1


///
/// @brief  Windows process token privileges.
///
/// Each field is a bitmap.
///
typedef struct _INTRO_TOKEN_PRIVILEGES
{
    QWORD           Present;            ///< The present privileges.
    QWORD           Enabled;            ///< The currently enabled privileges.
    QWORD           EnabledByDefault;   ///< The privileges that are enabled by default.
} INTRO_TOKEN_PRIVILEGES, *PINTRO_TOKEN_PRIVILEGES;


///
/// @brief  Windows process access control list (SACL/DACL)
///
typedef struct _INTRO_ACL
{
    BYTE AclRevision;
    WORD AclSize;
    WORD AceCount;
} INTRO_ACL, *PINTRO_ACL;


///
/// @brief  A security identifier.
///
/// See https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-sid
///
typedef struct _INTRO_WIN_SID
{
    BYTE            Revision;               ///< The revision of the SID.
    BYTE            SubAuthorityCount;      ///< The number of valid entries in the SubAuthority array.
    BYTE            IdentifierAuthority[6]; ///< Identifier authority entries.

    DWORD           SubAuthority[1];        ///< Sub authority entries.
} INTRO_WIN_SID, *PINTRO_WIN_SID;


/// @brief  The maximum number of sub authorities contained in a SID.
#define INTRO_WIN_SID_MAX_SUB_AUTHORITIES       15

/// @brief  The maximum size of a INTRO_WIN_SID structure.
#define INTRO_WIN_SID_MAX_SIZE  \
      (sizeof(INTRO_WIN_SID) - sizeof(DWORD) + (INTRO_WIN_SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))

///
/// @brief  Windows SID attributes
///
typedef struct _INTRO_SID_ATTRIBUTES
{
    /// TRUE if this was obtained from the RestrictedSids list.
    BOOLEAN                 IsRestricted;
    /// @brief      The attributes of the SID.
    ///
    /// See https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_groups_and_privileges
    DWORD                   Attributes;
    union
    {
        INTRO_WIN_SID       Sid;                                ///< The SID structure.
        BYTE                RawBuffer[INTRO_WIN_SID_MAX_SIZE];  ///< Raw version of the SID structure
    };
} INTRO_SID_ATTRIBUTES, *PINTRO_SID_ATTRIBUTES;

/// @brief  The maximum SID count included in an alert.
#define INTRO_SIDS_MAX_COUNT                4

///
/// @brief  A Windows token structure as reported by Introcore alerts.
///
typedef struct _INTRO_WIN_TOKEN
{
    /// TRUE if this is an impersonation token.
    BOOLEAN                 ImpersonationToken;
    /// The privileges associated with this token.
    INTRO_TOKEN_PRIVILEGES  Privileges;
    BYTE                    _padding[3];
    /// The number of valid entries in the SidsAndAttributes array.
    DWORD                   SidCount;
    /// The SIDs associated with this token.
    INTRO_SID_ATTRIBUTES    SidsAndAttributes[INTRO_SIDS_MAX_COUNT];

    /// The number of valid entries in the RestrictedSids array.
    DWORD                   RestrictedSidCount;
    /// The restricted SIDs associated with this token.
    INTRO_SID_ATTRIBUTES    RestrictedSids[INTRO_SIDS_MAX_COUNT];

    /// If TRUE, not all the entries from the guest's SidsAndAttributes were returned.
    BOOLEAN                 SidsBufferTooSmall;
    /// If TRUE, not all the entries from the guest's SidsAndAttributes were returned.
    BOOLEAN                 RestrictedSIdsBufferTooSmall;
    /// If FALSE, we failed to get the thread and the process token.
    BOOLEAN                 Valid;
} INTRO_WIN_TOKEN, *PINTRO_WIN_TOKEN;


///
/// @brief  Contains privileges and security identifiers information.
///
typedef union _INTRO_TOKEN
{
    INTRO_WIN_TOKEN         WindowsToken;   ///< A Windows token.
} INTRO_TOKEN, *PINTRO_TOKEN;

///
/// @brief  Describes a guest process.
///
/// Since certain operations that fill the fields in this structure may fail, the Valid field should be checked before
/// using any information present in the structure.
///
typedef struct _INTRO_PROCESS
{
    /// @brief  Set to True if the information in the structure is valid, False otherwise.
    BOOLEAN     Valid;
    DWORD       Pid;                                ///< The PID of the process.
    QWORD       Cr3;                                ///< The process Cr3 (NOT necessary the current CR3).
    /// @brief  The Process Creation Time, in 100 ns units since 1 January 1601.
    QWORD       CreationTime;
    CHAR        ImageName[ALERT_IMAGE_NAME_LEN];    ///< Image base name of the current process..
    WCHAR       Path[ALERT_PATH_MAX_LEN];           ///< The full path of the process. May not always be available.
    /// @brief  The thread token (if impersonating) or the process token (Windows only).
    INTRO_TOKEN SecurityInfo;
    CHAR        CmdLine[ALERT_CMDLINE_MAX_LEN];     ///< Process command line. May not always be available.
    QWORD       Context;                            ///< The context supplied when the process was protected.
    BOOLEAN     Wow64;                              ///< A boolean which is TRUE if the process is WoW64.
} INTRO_PROCESS, *PINTRO_PROCESS;


///
/// @brief  Describes a user-mode or kernel-mode module.
///
/// Since certain operations that fill the fields in this structure may fail, the Valid field should be checked
/// before using any information present in the structure.
///
typedef struct _INTRO_MODULE
{
    /// @brief  Set to True if the information in the structure is valid, False otherwise.
    BOOLEAN     Valid;
    QWORD       Base;                       ///< The guest linear address at which the module is loaded.
    DWORD       Size;                       ///< The size of the module.
    /// @brief  The value of the time date stamp field in the MZPE headers of a Windows module.
    DWORD       TimeDateStamp;
    WCHAR       Name[ALERT_PATH_MAX_LEN];   ///< The name of the module.
    WCHAR       Path[ALERT_PATH_MAX_LEN];   ///< The full path of the module.
} INTRO_MODULE, *PINTRO_MODULE;


///
/// @brief  Describes a driver object.
///
/// Since certain operations that fill the fields in this structure may fail, the Valid field should be checked before
/// using any information present in the structure.
/// This is available only for Windows guests.
///
typedef struct _INTRO_DRVOBJ
{
    /// @brief  Set to True if the information in the structure is valid, False otherwise.
    BOOLEAN     Valid;
    /// @brief  The guest linear address at which the driver object structure was allocated.
    QWORD       Address;
    WCHAR       Name[ALERT_PATH_MAX_LEN];       ///< The name of the driver.
    QWORD       Owner;                          ///< The base of the kernel module that owns this driver object.
} INTRO_DRVOBJ, *PINTRO_DRVOBJ;


///
/// @brief  Holds the CPU context for an event.
///
/// Since certain operations that fill the fields in this structure may fail, the Valid field should be checked before
/// using any information present in the structure.
///
typedef struct _INTRO_CPUCTX
{
    /// @brief  Set to True if the information in the structure is valid, False otherwise.
    BOOLEAN     Valid;
    DWORD       Cpu;                                ///< The VCPU number.
    /// @brief  The value of the guest RIP register when the event was generated.
    QWORD       Rip;
    /// @brief  The value of the guest CR3 register when the event was generated.
    QWORD       Cr3;
    CHAR        Instruction[ALERT_MAX_INSTRUX_LEN]; ///< The instruction found at RIP, in textual form.
} INTRO_CPUCTX, *PINTRO_CPUCTX;


///
/// @brief  Holds information about a memory write attempt.
///
typedef struct _INTRO_WRITE_INFO
{
    QWORD       OldValue[8];                        ///< The original value. Only the first Size bytes are valid.
    QWORD       NewValue[8];                        ///< The written value. Only the first Size bytes are valid.
    DWORD       Size;                               ///< The size of the access.
} INTRO_WRITE_INFO, *PINTRO_WRITE_INFO;


///
/// @brief  Holds information about a memory read attempt.
///
typedef struct _INTRO_READ_INFO
{
    QWORD       Value[8];                           ///< The original value. Only the first Size bytes are valid.
    DWORD       Size;                               ///< The size of the access.
} INTRO_READ_INFO, *PINTRO_READ_INFO;


///
/// @brief  Holds information about an execution attempt.
///
typedef struct _INTRO_EXEC_INFO
{
    QWORD       Rsp;        ///< The value of the guest RSP register at the moment of execution.
    QWORD       StackBase;  ///< The stack base for the thread that attempted the execution.
    QWORD       StackLimit; ///< The stack limit for the thread that attempted the execution.
    DWORD       Length;     ///< The length of the instruction.
} INTRO_EXEC_INFO, *PINTRO_EXEC_INFO;


///
/// @brief  Holds information about a security descriptor write attempt.
///
typedef struct _INTRO_SEC_DESC_INFO
{
    QWORD       OldAddress;         ///< The old security descriptor address.
    QWORD       NewAddress;         ///< The new security descriptor address.
    /// @brief  The CRC32 hash of the new security descriptor (after zeroing out SIDs with more than one sub-authority).
    DWORD       NewSecDescHash;

    /// @brief  The old security descriptor buffer (valid only if
    /// #INTRO_OBJECT_TYPE is #introObjectTypeSecDesc or #introObjectTypeAcl).
    BYTE        OldSecDesc[INTRO_SECURITY_DESCRIPTOR_SIZE];
    /// @brief  The size of the old security descriptor buffer (valid only if
    /// #INTRO_OBJECT_TYPE is #introObjectTypeSecDesc or #introObjectTypeAcl).
    DWORD       OldSecDescSize;

    /// @brief  The new security descriptor buffer (valid only if
    /// #INTRO_OBJECT_TYPE is #introObjectTypeSecDesc or #introObjectTypeAcl).
    BYTE        NewSecDesc[INTRO_SECURITY_DESCRIPTOR_SIZE];
    /// @brief  The size of the new security descriptor buffer (valid only if
    /// #INTRO_OBJECT_TYPE is #introObjectTypeSecDesc or #introObjectTypeAcl).
    DWORD       NewSecDescSize;
} INTRO_SEC_DESC_INFO, *PINTRO_SEC_DESC_INFO;

///
/// @brief  Holds code block patterns information.
///
/// This is used by the exception mechanism as a signature for the code that generated an alert.
/// These are extracted from the memory area around the instruction that generated an alert.
/// Since certain operations that fill the fields in this structure may fail, the Valid field should be checked before
/// using any information present in the structure.
///
typedef struct _INTRO_CODEBLOCKS
{
    BOOLEAN     Valid;          ///< Set to True if the information in the structure is valid, False otherwise.

    QWORD       StartAddress;   ///< The guest linear address from which the code blocks were extracted.
    QWORD       Rip;            ///< The value of the guest RIP at the moment of the alert.
    DWORD       RipCbIndex;     ///< Index in the CodeBlocks array for the pattern extracted for the instruction at Rip.
    DWORD       Count;          ///< The number of available entries in the CodeBlocks array.

    /// @brief  Array of actual code block patterns.
    struct _INTRO_CODE_BLOCK
    {
        /// @brief  The page offset from which the pattern was extracted. The page is considered to be StartAddress,
        /// rounded down to 4K.
        WORD        Offset;
        BYTE        Pivot;      ///< An instruction identifier used internally by the Introcore engine (see #CODE_INS).
        DWORD       Value;      ///< A hash of the code represented by this block.
    } CodeBlocks[ALERT_MAX_CODEBLOCKS];

} INTRO_CODEBLOCKS, *PINTRO_CODEBLOCKS;


///
/// @brief  Holds version information for Introcore and the currently loaded exceptions and CAMI files.
///
typedef struct _INTRO_VERSION_INFO
{
    WORD                ExceptionMajor;     ///< Exceptions major version.
    WORD                ExceptionMinor;     ///< Exceptions minor version.
    DWORD               ExceptionBuild;     ///< Exceptions build number.

    WORD                IntroMajor;         ///< Introcore major version.
    WORD                IntroMinor;         ///< Introcore minor version.
    WORD                IntroRevision;      ///< Introcore revision.
    DWORD               IntroBuildNumber;   ///< Introcore build number.

    DWORD               CamiMajor;          ///< CAMI major version.
    DWORD               CamiMinor;          ///< CAMI minor version.
    DWORD               CamiBuildNumber;    ///< CAMI build number.

    QWORD               OsVer;              ///< The version of the introspected operating system.
} INTRO_VERSION_INFO, *PINTRO_VERSION_INFO;


///
/// @brief  Holds register state information.
///
typedef struct _INTRO_GPRS
{
    QWORD RegRax;
    QWORD RegRcx;
    QWORD RegRdx;
    QWORD RegRbx;
    QWORD RegRsp;
    QWORD RegRbp;
    QWORD RegRsi;
    QWORD RegRdi;
    QWORD RegR8;
    QWORD RegR9;
    QWORD RegR10;
    QWORD RegR11;
    QWORD RegR12;
    QWORD RegR13;
    QWORD RegR14;
    QWORD RegR15;
    QWORD RegCr2;
    QWORD RegFlags;
    QWORD RegDr7;
    QWORD RegRip;
} INTRO_GPRS, *PINTRO_GPRS;


///
/// @brief  Holds the context in which an execution attempt was detected.
///
typedef struct _INTRO_EXEC_CONTEXT
{
    DWORD       CsType;             ///< The type of the code segment. Can be one of the IG_CS_TYPE values.
    INTRO_GPRS  Registers;          ///< The value of the guest registers at the moment of the execution.
    /// The contents of the guest memory page that contains the RIP at which the execution attempt was detected.
    BYTE        RipCode[0x1000];
} INTRO_EXEC_CONTEXT, *PINTRO_EXEC_CONTEXT;


///
/// @brief  Holds the data related to an execution attempt.
///
typedef struct _INTRO_EXEC_DATA
{
    INTRO_PROCESS           Process;        ///< The process in which the execution was attempted.
    INTRO_EXEC_CONTEXT      ExecContext;    ///< The context of the execution.
    INTRO_EXEC_INFO         StackInfo;      ///< Stack information.
    BOOLEAN                 Code64;         ///< True if the code was in 64-bit mode, False if it was in 32-bit mode.
} INTRO_EXEC_DATA, *PINTRO_EXEC_DATA;

///
/// @brief  Mitre attack techniques.
///
/// This is the Mitre Attack Technique ID, as defined at https://attack.mitre.org/techniques/enterprise/
///
typedef enum _MITRE_ID
{
    idCredDump = 1003,                  ///< Credential Dumping.
    idRootkit = 1014,                   ///< Rootkit.
    idSoftwarePacking = 1045,           ///< Software Packing.
    idProcInject = 1055,                ///< Process Injection.
    idScripting = 1064,                 ///< Scripting.
    idExploitPrivEsc = 1068,            ///< Exploitation for Privilege Escalation.
    idPowerShell = 1086,                ///< PowerShell.
    idProcHollowing = 1093,             ///< Process Hollowing.
    idExecApi = 1106,                   ///< Execution through API call.
    idExecModLoad = 1129,               ///< Execution through module load.
    idAccessToken = 1134,               ///< Access Token Manipulation.
    idHooking = 1179,                   ///< Hooking.
    idEWMI = 1181,                      ///< Extra Window Memory Injection.
    idProcDoppelganging = 1186,         ///< Process Doppelganging.
    idExploitClientExec = 1203,         ///< Exploitation for Client Execution.
    idTrustedDevUtil = 1127,            ///< Trusted Developer Utilities.
    idExploitRemote = 1210,             ///< Exploitation of Remote Services.
    idKernModExt = 1215                 ///< Kernel Modules and Extensions.
} MITRE_ID;


#pragma pack(push, 1)

///
/// @brief  The common header used by exception information.
///
/// This is used internally by Introcore in order to facilitate the add exception from alert mechanism used by
/// #GLUE_IFACE.AddExceptionFromAlert.
///
typedef struct _INTRO_ALERT_EXCEPTION_HEADER
{
    WORD        Version;        ///< The version of the exception information.
    QWORD       ViolationFlags; ///< A combination of @ref group_alert_flags values describing the alert.
    BOOLEAN     Valid;          ///< Set to True if the information in the structure is valid, False otherwise.

    BYTE        _Reserved1;     ///< Reserved.
    DWORD       _Reserved2;     ///< Reserved.
    DWORD       _Reserved3;     ///< Reserved.
} INTRO_ALERT_EXCEPTION_HEADER;

#pragma pack(pop)


///
/// @brief  Common violation header.
///
typedef struct _INTRO_VIOLATION_HEADER
{
    DWORD               ViolationVersion;   ///< The version of the alert. See #INTRO_VIOLATION_VERSION.
    /// @brief  Information about the version of Introcore and the guest operating system.
    INTRO_VERSION_INFO  VerInfo;
    INTRO_ACTION        Action;             ///< The action that was taken as the result of this alert.
    INTRO_ACTION_REASON Reason;             ///< The reason for which Action was taken.
    INTRO_CPUCTX        CpuContext;         ///< The context of the CPU that triggered the alert.
    INTRO_PROCESS       CurrentProcess;     ///< The current process.
    QWORD               Flags;              ///< A combination of ALERT_FLAG_* values describing the alert.
    MITRE_ID            MitreID;            ///< The Mitre ID that corresponds to this attack.

    union
    {
        /// Exception information used by #GLUE_IFACE.AddExceptionFromAlert.
        BYTE                            Exception[ALERT_EXCEPTION_SIZE];
        INTRO_ALERT_EXCEPTION_HEADER    ExHeader;   ///< The header of the exception information.
    };
} INTRO_VIOLATION_HEADER, *PINTRO_VIOLATION_HEADER;


///
/// @brief  Event structure for EPT violations.
///
/// This event can describe multiple memory access violations: read, write, and execute.
///
typedef struct _EVENT_EPT_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;         ///< The alert header.

    struct
    {
        INTRO_MODULE        Module;         ///< The module that did the malicious access.
        INTRO_MODULE        ReturnModule;   ///< The module to which the current code returns to.
        INTRO_PROCESS       Process;        ///< The process that did the malicious access.

        struct
        {
            BOOLEAN User : 1;               ///< Set if it is a KM-UM write due to an injection from user-mode.
            BOOLEAN Kernel : 1;             ///< Set if it is a KM-UM write due to an injection from kernel-mode.
        } Injection;
    } Originator;

    /// Describes the accessed memory area.
    /// Valid only if Violation is #IG_EPT_HOOK_READ or #IG_EPT_HOOK_WRITE
    struct
    {
        /// The type of the accessed memory area.
        INTRO_OBJECT_TYPE   Type;
        union
        {
            /// The module that was modified.
            INTRO_MODULE    Module;
            /// The driver object that was modified. Valid only if Type is #introObjectTypeDriverObject.
            INTRO_DRVOBJ    DriverObject;
        };
        /// The IDT entry that was modified. Valid only if Type is #introObjectTypeIdt.
        BYTE                IdtEntry;
    } Victim;

    union
    {
        /// The original value and the value that the guest tried to write.
        /// Valid only if Violation is #IG_EPT_HOOK_WRITE.
        INTRO_WRITE_INFO    WriteInfo;

        /// The original value and the value that the guest tried to read.
        /// Valid only if Violation is #IG_EPT_HOOK_WRITE.
        INTRO_READ_INFO    ReadInfo;

        /// Execution information. Valid only if Violation is #IG_EPT_HOOK_EXECUTE.
        INTRO_EXEC_INFO     ExecInfo;
    };

    INTRO_CODEBLOCKS        CodeBlocks;     ///< Code blocks extracted for the alert.

    BYTE                    Violation;      ///< The type of the access. It must be one of the #IG_EPT_HOOK_TYPE values.

    /// The start of the monitored guest virtual memory area for which this alert was generated.
    QWORD                   HookStartVirtual;
    /// The start of the monitored guest physical memory area for which this alert was generated.
    QWORD                   HookStartPhysical;

    QWORD                   VirtualPage;    ///< The guest virtual page in which the access was made.
    QWORD                   PhysicalPage;   ///< The guest physical page in which the access was made.
    DWORD                   Offset;         ///< The offset inside the page where the violation took place.

    QWORD                   ZoneTypes;      ///< The types of the accessed memory area.

    /// The name of the section in which the RIP resides. May be empty.
    CHAR                    RipSectionName[ALERT_MAX_SECTION_NAME_LEN];

    /// The RIP at which the code that triggered the alert returns.
    QWORD                   ReturnRip;
    /// The name of the section in which ReturnRip resides. May be empty.
    CHAR                    ReturnRipSectionName[ALERT_MAX_SECTION_NAME_LEN];

    /// The name of the modified section, if any.
    CHAR                    ModifiedSectionName[ALERT_MAX_SECTION_NAME_LEN];
    /// The name of the modified function, if any. This is the same as Export.Name[0].
    CHAR                    FunctionName[ALERT_MAX_FUNCTION_NAME_LEN];
    /// The hash of the modified function name. This is the same as Export.Hash[0].
    DWORD                   FunctionNameHash;
    /// The offset relative to the function start address at which the write was attempted.
    /// This is the same as Export.Delta. Valid only if a function was modified.
    DWORD                   Delta;

    /// All the names used to export the modified function.
    /// In certain cases, the same function can be exported with multiple names by a module.
    struct
    {
        /// Array of all the extracted function names.
        char                Name[ALERT_MAX_FUNCTIONS][ALERT_MAX_FUNCTION_NAME_LEN];
        /// Array of all the extracted function hashes. Export.Hash[i] is the hash for Export.Name[i].
        DWORD               Hash[ALERT_MAX_FUNCTIONS];
        /// The same as Delta.
        DWORD               Delta;
    } Export;

    /// Information about the instruction that triggered the alert.
    INTRO_EXEC_CONTEXT      ExecContext;
} EVENT_EPT_VIOLATION, *PEVENT_EPT_VIOLATION;


///
/// @brief  Event structure for MSR violation.
///
typedef struct _EVENT_MSR_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;         ///< The alert header.

    ///
    /// Describes the attacker
    ///
    struct
    {
        INTRO_MODULE        Module;         ///< The module that did the malicious access.
        INTRO_MODULE        ReturnModule;   ///< The module to which the current code return to.
    } Originator;

    union
    {
        DWORD               Msr;            ///< The ID of the MSR as defined by the Intel documentation.
    } Victim;

    /// @brief  The original value of the MSR and the value that the guest tried to write.
    INTRO_WRITE_INFO        WriteInfo;

    INTRO_CODEBLOCKS        CodeBlocks;     ///< Code blocks extracted for the alert.

    INTRO_EXEC_CONTEXT      ExecContext;    ///< Information about the instruction that triggered the alert.
} EVENT_MSR_VIOLATION, *PEVENT_MSR_VIOLATION;


///
/// @brief  Event structure for CR violation.
///
typedef struct _EVENT_CR_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;         ///< The alert header.

    ///
    /// Describes the attacker.
    ///
    struct
    {
        INTRO_MODULE        Module;         ///< The module that attempted the write.
        INTRO_MODULE        ReturnModule;   ///< The module to which the current code return to.
    } Originator;

    union
    {
        DWORD               Cr;             ///< The number of the modified control register.
    } Victim;


    /// @brief  The original value of the register and the value that the guest tried to write.
    INTRO_WRITE_INFO        WriteInfo;

    INTRO_CODEBLOCKS        CodeBlocks;     ///< Code blocks extracted for the alert.

    INTRO_EXEC_CONTEXT      ExecContext;    ///< Information about the instruction that triggered the alert.

} EVENT_CR_VIOLATION, *PEVENT_CR_VIOLATION;


///
/// @brief  Event structure for XCR violation.
///
typedef struct _EVENT_XCR_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;         ///< The alert header,

    ///
    /// Describes the attacker
    ///
    struct
    {
        INTRO_MODULE        Module;         ///< The module that attempted the write.
        INTRO_MODULE        ReturnModule;   ///< The module to which the current code return to.
    } Originator;

    union
    {
        DWORD               Xcr;            ///< The number of the modified extended control register.
    } Victim;

    /// @brief  The original value of the register and the value that the guest tried to write.
    INTRO_WRITE_INFO        WriteInfo;

    INTRO_CODEBLOCKS        CodeBlocks;     ///< Code blocks extracted for the alert.

    INTRO_EXEC_CONTEXT      ExecContext;    ///< Information about the instruction that triggered the alert.
} EVENT_XCR_VIOLATION, *PEVENT_XCR_VIOLATION;


///
/// @brief  The type of a memory copy violation.
///
typedef enum _MEMCOPY_VIOLATION_TYPE
{
    /// This is a classic code injection attempt that simply modifies the memory of the victim process.
    memCopyViolationWrite = 0,

    /// This represents a read done from another process.
    memCopyViolationRead,

    /// This represents an attempt of modifying the context of another thread.
    memCopyViolationSetContextThread,

    /// This represents an attempt to queue an APC into the victim process.
    memCopyViolationQueueApcThread,

    /// This represents an attempt to set an instrument callback inside the victim process.
    memCopyViolationInstrument,

} MEMCOPY_VIOLATION_TYPE;


///
/// @brief  Memory access violations that cross a process boundary.
///
/// Represents an attempt to write or read the memory of another process, or to hijack the execution flow of
// another process.
///
typedef struct _EVENT_MEMCOPY_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;     ///< The alert header.

    struct
    {
        INTRO_PROCESS       Process;    ///< The process that attempted the access.
    } Originator;

    struct
    {
        /// @brief  The destination process.
        INTRO_PROCESS       Process;
        /// @brief  The module which was written or read.
        ///
        /// May be valid only if ViolationType is #memCopyViolationWrite or #memCopyViolationRead.
        ///
        INTRO_MODULE        Module;
    } Victim;

    /// @brief  The virtual address of the source buffer.
    ///
    ///     If ViolationType is #memCopyViolationWrite this is the address in the attacker process which
    /// contains the data that should be written.
    ///     If ViolationType is #memCopyViolationRead this is the address in the victim process from
    /// which the read was attempted.
    ///     If ViolationType is #memCopyViolationSetContextThread this is the address of the originator kernel
    /// thread structure.
    ///     If ViolationType is #memCopyViolationQueueApcThread this is the address of the victim kernel
    /// thread structure.
    QWORD                   SourceVirtualAddress;

    /// @brief  The virtual address of the destination buffer.
    ///
    ///     If ViolationType is #memCopyViolationWrite this is the address in the victim process which was written.
    ///     If ViolationType is #memCopyViolationRead this is the address in the originator process to which the
    /// contents of SourceVirtualAddress are read to.
    ///     If ViolationType is #memCopyViolationSetContextThread this is the address of the victim kernel
    /// thread structure.
    ///     If ViolationType is #memCopyViolationQueueApcThread this is the new RIP value for the attacked thread.
    QWORD                   DestinationVirtualAddress;

    /// The size of the access.
    DWORD                   CopySize;

    /// The type of the access.
    MEMCOPY_VIOLATION_TYPE  ViolationType;

    /// True if the contents of RawDump are valid, False if not.
    BOOLEAN                 DumpValid;

    /// @brief  The source buffer contents.
    ///
    ///     If ViolationType is #memCopyViolationWrite this holds the information that the attacker tried to write.
    ///     If ViolationType is #memCopyViolationRead this is not filled, as it may contain sensitive information.
    ///     If ViolationType is #memCopyViolationSetContextThread this is the context thread structure,
    /// as defined by Windows.
    ///     If ViolationType is #memCopyViolationQueueApcThread this is the contents of the page containing the new Rip.
    BYTE                    RawDump[ALERT_MAX_INJ_DUMP_SIZE];

    /// @brief  The name of the accessed function, if any.
    ///
    /// If ViolationType is #memCopyViolationWrite or #memCopyViolationRead this is the name of the function that was
    /// written or read, if any. If ViolationType is memCopyViolationSetContextThread or memCopyViolationQueueApcThread
    /// this is the name of currently executing function in the victim thread, if any. It is the same as Export.Name[0].
    CHAR                    FunctionName[ALERT_MAX_FUNCTION_NAME_LEN];

    /// The hash of the FunctionName. It is the same as Export.Hash[0].
    DWORD                   FunctionNameHash;

    /// The offset inside the affected function at which the access was made.
    DWORD                   Delta;

    /// @brief  All the names used to export the modified function.
    ///
    /// In certain cases, the same function can be exported with multiple names by a module.
    struct
    {
        /// Array of all the extracted function names.
        char                Name[ALERT_MAX_FUNCTIONS][ALERT_MAX_FUNCTION_NAME_LEN];

        /// Array of all the extracted function hashes.Export.Hash[i] is the hash for Export.Name[i].
        DWORD               Hash[ALERT_MAX_FUNCTIONS];

        /// The same as Delta.
        DWORD               Delta;
    } Export;
} EVENT_MEMCOPY_VIOLATION, *PEVENT_MEMCOPY_VIOLATION;

///
/// @brief  Translation violation types.
///
typedef enum _TRANS_VIOLATION_TYPE
{
    /// @brief  After a page was swapped-in, its hash no longer matches the one it had when it was swapped-out.
    transViolationPageHash,
    transViolationProcessCr3,   ///< The CR3 of a process was changed.
    transViolationSelfMap,      ///< The self-map entry inside a root page-table changed.
    /// @brief  A translation was modified without us intercepting it. This points to a bug in Introcore.
    transViolationWatchdog,
    transViolationVeAgent       ///< A translation inside the \#VE agent was changed.
} TRANS_VIOLATION_TYPE;

///
/// @brief  Event structure for illegal paging-structures modifications.
///
typedef struct _EVENT_TRANSLATION_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;         ///< The alert header.

    struct
    {
        INTRO_MODULE        Module;         ///< The module that modified the translation.
        INTRO_MODULE        ReturnModule;   ///< The module to which the current code return to.
    } Originator;

    struct
    {
        QWORD               VirtualAddress; ///< The Virtual Address whose translation is being modified.
    } Victim;

    /// @brief  The original and new address to which VirtualAddress translates.
    ///
    /// If VirtualAddress is 0xFFFFFFFFFFFFFFFF, this indicates that an invalid Cr3 was loaded for the indicated
    /// process and WriteInfo.OldValue is the original Cr3 of the process and WriteInfo.NewValue is the new Cr3 of
    /// the process.
    INTRO_WRITE_INFO        WriteInfo;

    TRANS_VIOLATION_TYPE    ViolationType;  /// The type of the translation violation.
} EVENT_TRANSLATION_VIOLATION, *PEVENT_TRANSLATION_VIOLATION;

///
/// @brief  Event structure for integrity violations on monitored structures.
///
/// These events are triggered by the integrity check mechanism, which is invoked on the timer event, so Introcore may
/// not always be able to block them. For the same reason the information needed for the alert may no longer be present
/// in the guest memory when Introcore detects the violation.
///
typedef struct _EVENT_INTEGRITY_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;         ///< The alert header.

    struct
    {
        INTRO_MODULE        Module;         ///< The module that modified the monitored region.
        INTRO_PROCESS       Process;        ///< The module to which the current code return to.
    } Originator;

    struct
    {
        INTRO_MODULE        Module;         ///< The module that modified the translation.
    } Return;

    struct
    {
        INTRO_OBJECT_TYPE   Type;           ///< The type of the modified object.
        /// NULL-terminated string with a human readable description of the modified object.
        WCHAR               Name[ALERT_PATH_MAX_LEN];
        union
        {
            /// The process which had the access token modified. Valid only if Type is #introObjectTypeTokenPtr.
            INTRO_PROCESS   Process;
            /// The modified driver object. Valid only if Type is #introObjectTypeDriverObject.
            INTRO_DRVOBJ    DriverObject;
            /// The modified IDT entry. Valid only if Type is #introObjectTypeIdt.
            BYTE            IdtEntry;
        };
    } Victim;

    union
    {
        /// The original and the new value (valid only if #INTRO_OBJECT_TYPE in NOT #introObjectTypeSecDesc
        /// or #introObjectTypeAcl).
        INTRO_WRITE_INFO        WriteInfo;
        /// The original and the new value of the security descriptor address, buffer and hash (valid only if
        /// #INTRO_OBJECT_TYPE is #introObjectTypeSecDesc or #introObjectTypeAcl).
        INTRO_SEC_DESC_INFO     SecDescWriteInfo;
    };

    /// The guest virtual address at which the monitored integrity region starts.
    QWORD                   BaseAddress;
    /// The guest virtual address which was modified.
    QWORD                   VirtualAddress;
    /// The size of the modified memory area.
    DWORD                   Size;
} EVENT_INTEGRITY_VIOLATION, *PEVENT_INTEGRITY_VIOLATION;


///
/// @brief  Event structure for GDTR/IDTR descriptor tables modifications.
///
typedef struct _EVENT_DTR_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;         ///< The alert header.

    struct
    {
        INTRO_MODULE        Module;         ///< The module that modified the DTR.
        INTRO_MODULE        ReturnModule;   ///< The module to which the current code return to.
    } Originator;

    struct
    {
        INTRO_OBJECT_TYPE   Type;           ///< The type of the modified register.
    } Victim;

    INTRO_WRITE_INFO        WriteInfo;      ///< The original value and the new value of the register.

    INTRO_CODEBLOCKS        CodeBlocks;     ///< Code blocks extracted for the alert.

    INTRO_EXEC_CONTEXT      ExecContext;    ///< Information about the instruction that triggered the alert.
} EVENT_DTR_VIOLATION, *PEVENT_DTR_VIOLATION;


///
/// @brief  Process creation violation flags.
///
typedef enum
{
    /// Process creation violation without any DPI heuristic being triggered.
    INT_PC_VIOLATION_NORMAL_PROCESS_CREATION = 0,

    /// The parent of a process tried to obtain debug privileges over the child.
    INT_PC_VIOLATION_DPI_DEBUG_FLAG = (1 << 0),

    /// The parent of a process had a pivoted stack when it created the child.
    INT_PC_VIOLATION_DPI_PIVOTED_STACK = (1 << 1),

    /// The parent of a process has a stolen access token when it created the child.
    INT_PC_VIOLATION_DPI_STOLEN_TOKEN = (1 << 2),

    /// The creation of a process was attempted while the parent had its heap sprayed.
    INT_PC_VIOLATION_DPI_HEAP_SPRAY = (1 << 3),

    /// The creation of a process was attempted with token privileges altered in a malicious way.
    INT_PC_VIOLATION_DPI_TOKEN_PRIVS = (1 << 4),

    /// The thread which created the process has started execution on some suspicious code.
    INT_PC_VIOLATION_DPI_THREAD_START = (1 << 5),

    /// The parent of a process has an altered security descriptor pointer.
    INT_PC_VIOLATION_DPI_SEC_DESC = (1 << 6),

    /// The parent of a process has an altered access control entry (inside SACL or DACL).
    INT_PC_VIOLATION_DPI_ACL_EDIT = (1 << 7),
} INTRO_PC_VIOLATION_TYPE;


///
/// @brief  Structure for keeping the relevant DPI violation information.
///
typedef union _INTRO_DPI_EXTRA_INFO
{
    struct
    {
        INTRO_PROCESS Debugger;             ///< The debugger of the current process. May or may not be the parent.
    } DpiDebugFlag;

    struct
    {
        QWORD CurrentStack;                 ///< The current stack of the parent process.
        QWORD StackBase;                    ///< The known stack base of the parent process.
        QWORD StackLimit;                   ///< The known stack limit of the parent process.
        QWORD Wow64CurrentStack;            ///< The current stack of the parent process in WoW64 mode.
        QWORD Wow64StackBase;               ///< The known stack base of the parent process in WoW64 mode.
        QWORD Wow64StackLimit;              ///< The known stack limit of the parent process in WoW64 mode.
        BYTE TrapFrameContent[512];         ///< The content of the trap frame where the current stack has been found.
    } DpiPivotedStack;

    struct
    {
        INTRO_PROCESS StolenFrom;           ///< The process from which the token was stolen.
    } DpiStolenToken;

    struct
    {
        struct
        {
            DWORD Mapped : 1;               ///< The bit is set if the i-th page could be mapped.
            /// @brief The bit is set if the i-th page was detected as malicious by shemu.
            DWORD Detected : 1;
            /// @brief  The number of heap values in the page. Since the max value can be 1024, 11 bits are needed.
            DWORD HeapValCount : 11;
            /// @brief  The offset where the detection on the given page was given, if Detection is equal to 1.
            DWORD Offset : 12;
            DWORD Executable : 1;           ///< True if the page is executable in the translation.
            DWORD Reserved : 7;             ///< Reserved for further use.
        } HeapPages[0xF];

        QWORD ShellcodeFlags;               ///< The shellcode flags given by shemu on the detected page.

        BYTE DetectedPage[0x1000];          ///< The page which was detected through shemu as malicious.
        BYTE MaxHeapValPageContent[0x1000]; ///< The copied page which has the most heap values in it.
    } DpiHeapSpray;

    struct
    {
        QWORD OldEnabled;                   ///< The old Privileges.Enabled value in the parent's token.
        /// @brief  The new Privileges.Enabled value in the parent's token, which was deemed malicious.
        QWORD NewEnabled;
        QWORD OldPresent;                   ///< The old Privileges.Present value in the parent's token.
        /// @brief The new Privileges.Present value in the parent's token, which was deemed malicious.
        QWORD NewPresent;
    } DpiTokenPrivs;

    struct
    {
        QWORD ShellcodeFlags;               ///< The shellcode flags given by shemu on the detected page.
        QWORD StartAddress;                 ///< The address where the thread started executing.
        BYTE StartPage[0x1000];             ///< The copied page from where the thread started executing.
    } DpiThreadStart;

    struct
    {
        /// @brief This variable may indicate the victim process (where security descriptor has been stolen from).
        /// If the security descriptor is invalid, this variable will be uninitialized.
        INTRO_PROCESS SecDescStolenFrom;

        QWORD OldPointerValue;              ///< Old value.
        QWORD NewPointerValue;              ///< New value.

        INTRO_ACL OldSacl;                  ///< The old SACL header.
        INTRO_ACL OldDacl;                  ///< The old DACL header.

        INTRO_ACL NewSacl;                  ///< The new SACL header.
        INTRO_ACL NewDacl;                  ///< The new DACL header.
    } DpiSecDescAcl;
} INTRO_DPI_EXTRA_INFO, *PINTRO_DPI_EXTRA_INFO;


///
/// @brief  Event structure for process creation violation events.
///
typedef struct _EVENT_PROCESS_CREATION_VIOLATION
{
    INTRO_VIOLATION_HEADER          Header;     ///< The alert header.

    /// @brief  The process that was compromised.
    ///
    /// Based on the PcType value this has different meanings:
    ///
    /// --------------------------------------------------------------------------
    /// | PcType value                         | Victim                          |
    /// |--------------------------------------|---------------------------------|
    /// | 0                                    | parent process                  |
    /// | INT_PC_VIOLATION_DPI_DEBUG_FLAG      | child process                   |
    /// | INT_PC_VIOLATION_DPI_PIVOTED_STACK   | parent process                  |
    /// | INT_PC_VIOLATION_DPI_STOLEN_TOKEN    | the real parent process         |
    /// | INT_PC_VIOLATION_DPI_TOKEN_PRIVS     | the real parent process         |
    /// | INT_PC_VIOLATION_DPI_HEAP_SPRAY      | parent process                  |
    /// | INT_PC_VIOLATION_DPI_THREAD_START    | parent process                  |
    /// | INT_PC_VIOLATION_DPI_SEC_DESC        | the real parent process         |
    /// | INT_PC_VIOLATION_DPI_ACL_EDIT        | the real parent process         |
    /// --------------------------------------------------------------------------
    INTRO_PROCESS                   Victim;

    /// @brief  The process that attempted the violation.
    ///
    /// Based on the PcType value this has different meanings:
    ///
    /// --------------------------------------------------------------------------
    /// | PcType value                         | Victim                          |
    /// |--------------------------------------|---------------------------------|
    /// | 0                                    | child process                   |
    /// | INT_PC_VIOLATION_DPI_DEBUG_FLAG      | parent process                  |
    /// | INT_PC_VIOLATION_DPI_PIVOTED_STACK   | child process                   |
    /// | INT_PC_VIOLATION_DPI_STOLEN_TOKEN    | child process                   |
    /// | INT_PC_VIOLATION_DPI_TOKEN_PRIVS     | child process                   |
    /// | INT_PC_VIOLATION_DPI_HEAP_SPRAY      | child process                   |
    /// | INT_PC_VIOLATION_DPI_THREAD_START    | child process                   |
    /// | INT_PC_VIOLATION_DPI_SEC_DESC        | child process                   |
    /// | INT_PC_VIOLATION_DPI_ACL_EDIT        | child process                   |
    /// --------------------------------------------------------------------------
    INTRO_PROCESS                   Originator;

    /// @brief  The type of process creation violation.
    ///
    /// If non-zero, this is a deep process inspection event, which has several classes of detections,
    /// described by #INTRO_PC_VIOLATION_TYPE.
    INTRO_PC_VIOLATION_TYPE         PcType;

    /// @brief  A structure which contains extra information regarding the DPI violation that was detected.
    ///
    /// The correct valid field of the union depends on the PcType value:
    ///
    /// --------------------------------------------------------------------------------
    /// | PcType value                         | Victim                                |
    /// |--------------------------------------|---------------------------------------|
    /// | 0                                    | not valid field                       |
    /// | INT_PC_VIOLATION_DPI_DEBUG_FLAG      | #INTRO_DPI_EXTRA_INFO.DpiDebugFlag    |
    /// | INT_PC_VIOLATION_DPI_PIVOTED_STACK   | #INTRO_DPI_EXTRA_INFO.DpiPivotedStack |
    /// | INT_PC_VIOLATION_DPI_STOLEN_TOKEN    | #INTRO_DPI_EXTRA_INFO.DpiStolenToken  |
    /// | INT_PC_VIOLATION_DPI_HEAP_SPRAY      | #INTRO_DPI_EXTRA_INFO.DpiHeapSpray    |
    /// | INT_PC_VIOLATION_DPI_THREAD_START    | #INTRO_DPI_EXTRA_INFO.DpiThreadStart  |
    /// | INT_PC_VIOLATION_DPI_SEC_DESC        | #INTRO_DPI_EXTRA_INFO.DpiSecDescAcl   |
    /// | INT_PC_VIOLATION_DPI_ACL_EDIT        | #INTRO_DPI_EXTRA_INFO.DpiSecDescAcl   |
    /// --------------------------------------------------------------------------------
    INTRO_DPI_EXTRA_INFO            DpiExtraInfo;
} EVENT_PROCESS_CREATION_VIOLATION, *PEVENT_PROCESS_CREATION_VIOLATION;


///
/// @brief  Event structure for suspicious module load into processes.
///
typedef struct _EVENT_MODULE_LOAD_VIOLATION
{
    INTRO_VIOLATION_HEADER  Header;     ///< The alert header.

    INTRO_PROCESS           Victim;     ///< The process in which the module has loaded.

    struct
    {
        INTRO_MODULE        Module;         ///< The loaded module.
        INTRO_MODULE        ReturnModule;   ///< The module which called the entry function of the suspicious module.
    } Originator;

    /// @brief  The RIP from which the suspicious module was called.
    ///
    /// This points inside Originator.ReturnModule.
    QWORD                   ReturnRip;

    /// The name of the section in which ReturnRip resides.
    CHAR                    ReturnRipSectionName[ALERT_MAX_SECTION_NAME_LEN];

    /// The name of the section in which the function executed by the loaded module is found.
    CHAR                    RipSectionName[ALERT_MAX_SECTION_NAME_LEN];
} EVENT_MODULE_LOAD_VIOLATION, *PEVENT_MODULE_LOAD_VIOLATION;

///
/// @brief  Event structure for detections provided by additional scan engines.
///
typedef struct _EVENT_ENGINES_DETECTION_VIOLATION
{
    INTRO_VIOLATION_HEADER      Header; ///< The alert header.
    INTRO_ENG_NOTIF_TYPE        Type;   ///< The type of the alert.

    /// A NULL-terminated string with the detection name, as provided by the engines.
    CHAR                        DetectionName[ALERT_MAX_DETECTION_NAME];
    /// A NULL-terminated string with the engines versions.
    CHAR                        EnginesVersion[ALERT_MAX_ENGINES_VERSION];

    union
    {
        /// @brief  Execution context.
        ///
        /// Valid only if Type is #introEngineNotificationCodeExecution.
        INTRO_EXEC_DATA ExecViolation;

        /// @brief  Command line of the process.
        ///
        /// Valid only if Type is #introEngineNotificationCmdLine.
        struct
        {
            /// The process that received the command line.
            INTRO_PROCESS           Victim;
            /// The process that provided the command line.
            INTRO_PROCESS           Originator;
        } CmdLineViolation;
    };
} EVENT_ENGINES_DETECTION_VIOLATION, *PEVENT_ENGINES_DETECTION_VIOLATION;


///
/// @brief  Event structure for plain data/message passing.
///
typedef struct _EVENT_INTROSPECTION_MESSAGE
{
    CHAR                    Message[ALERT_MAX_MESSAGE_SIZE];    ///< Raw data.
} EVENT_INTROSPECTION_MESSAGE, *PEVENT_INTROSPECTION_MESSAGE;


///
/// @brief  Event structure for process creation/termination.
///
/// This is an informational event, not an alert.
///
typedef struct _EVENT_PROCESS_EVENT
{
    /// True if the process was created, False if it was terminated.
    BOOLEAN                 Created;
    /// True if the process is protected.
    BOOLEAN                 Protected;

    /// @brief  True if the process crashed.
    ///
    /// This field is valid only if Created is False.
    /// This information is available only on 64-bit Windows versions newer than 10586.
    BOOLEAN                 Crashed;
    BOOLEAN                 Reserved;

    /// @brief  The exit code of the process.
    ///
    /// This field is valid only if Created is False.
    DWORD                   ExitStatus;

    /// The currently active process.
    INTRO_PROCESS           CurrentProcess;

    /// The process that is being created or terminated.
    INTRO_PROCESS           Child;
    /// The parent of the process.
    INTRO_PROCESS           Parent;
} EVENT_PROCESS_EVENT, *PEVENT_PROCESS_EVENT;


///
/// @brief  Event structure for module loading and unloading.
///
/// User mode events are sent only when an alert is sent for a process, due to performance concerns.
/// Sending one event for each user mode module load and unload when it happens may severely impact the guest.
///
typedef struct _EVENT_MODULE_EVENT
{
    /// True if the module was loaded, False if it was unloaded.
    BOOLEAN                 Loaded;
    /// True if the module is protected.
    BOOLEAN                 Protected;
    /// True if this is a user mode module, False if it is a kernel mode module.
    BOOLEAN                 UserMode;

    /// @brief  The currently active process.
    ///
    /// If UserMode is True, this is the process in which the module was loaded.
    INTRO_PROCESS           CurrentProcess;

    /// The module for which this event was triggered.
    INTRO_MODULE            Module;
} EVENT_MODULE_EVENT, *PEVENT_MODULE_EVENT;


///
/// @brief  Event structure for guest OS crashes.
///
typedef struct _EVENT_CRASH_EVENT
{
    QWORD                   Reason; ///< The bugcheck reason.
    QWORD                   Param1; ///< First parameter.
    QWORD                   Param2; ///< Second parameter.
    QWORD                   Param3; ///< Third parameter.
    QWORD                   Param4; ///< Fourth parameter.

    INTRO_PROCESS           CurrentProcess; ///< The currently active process.
} EVENT_CRASH_EVENT, *PEVENT_CRASH_EVENT;


///
/// @brief  Event structure for process exceptions.
///
/// This is usually sent when during the runtime of a user mode process a hardware exception is triggered.
typedef struct _EVENT_EXCEPTION_EVENT
{
    /// @brief  The code of the exception.
    ///
    /// This is usually a NTSTATUS value that describes the exception.
    QWORD                   ExceptionCode;
    /// The RIP at which the exception was triggered.
    QWORD                   Rip;
    /// True if the exception is considered to be continuable.
    BOOLEAN                 Continuable;

    /// The process in which the exception was triggered.
    INTRO_PROCESS           CurrentProcess;
} EVENT_EXCEPTION_EVENT, *PEVENT_EXCEPTION_EVENT;


///
/// @brief  Event structure for connections.
///
/// Available only if Introcore received the #INTRO_OPT_EVENT_CONNECTIONS activation flag.
/// If process is protected with the #PROC_OPT_PROT_EXPLOIT flag and an exploit attempt is detected, when the exploit
/// alert is sent, one event of this type will be sent for every connection that the process has open.
///
typedef struct _EVENT_CONNECTION_EVENT
{
    INTRO_NET_AF            Family;     ///< Address family.
    INTRO_NET_STATE         State;      ///< The state of the connection.

    /// Local address.
    union
    {
        BYTE                Ipv6[16];   ///< Valid only if Family is #introNetAfIpv6.
        DWORD               Ipv4;       ///< Valid only if Family is #introNetAfIpv4.
    } LocalAddress;

    /// Remote address.
    union
    {
        BYTE                Ipv6[16];   ///< Valid only if Family is #introNetAfIpv6.
        DWORD               Ipv4;       ///< Valid only if Family is #introNetAfIpv4.
    } RemoteAddress;

    WORD                    LocalPort;  ///< Local port.
    WORD                    RemotePort; ///< Remote port.

    INTRO_PROCESS           Owner;      ///< The process that owns the connection.
} EVENT_CONNECTION_EVENT, *PEVENT_CONNECTION_EVENT;


//
// =====================================================================================================================
//


///
/// @brief  The type of the introspected operating system.
///
typedef enum
{
    introGuestUnknown,  ///< Unknown.
    introGuestWindows,  ///< Windows.
    introGuestLinux     ///< Linux.
} INTRO_GUEST_TYPE;

// Engines structures

///
/// @brief  Notification header for scan engines alerts.
///
typedef struct _ENG_NOTIFICATION_HEADER
{
    /// @brief Action requested by the scan engines.
    ///
    /// For asynchronous scans this action is not enforceable and has a purely informational purpose.
    INTRO_ACTION            RequestedAction;
    /// The type of the notification.
    INTRO_ENG_NOTIF_TYPE    Type;
    /// The guest operating system type.
    INTRO_GUEST_TYPE        OsType;
    /// A NULL-terminated string with the name of the engines detection, if any.
    CHAR                    DetectionName[ALERT_MAX_DETECTION_NAME];
    /// A NULL-terminated string with the version of the engines.
    CHAR                    EnginesVersion[ALERT_MAX_ENGINES_VERSION];
} ENG_NOTIFICATION_HEADER, *PENG_NOTIFICATION_HEADER;

///
/// @brief  Execution notification for scan engines.
///
typedef struct _ENG_NOTIFICATION_CODE_EXEC
{
    ENG_NOTIFICATION_HEADER Header; ///< Notification header.
    INTRO_EXEC_DATA ExecutionData;  ///< Execution information.
} ENG_NOTIFICATION_CODE_EXEC, *PENG_NOTIFICATION_CODE_EXEC;

///
/// @brief Command line notification for scan engines.
///
typedef struct _ENG_NOTIFICATION_CMD_LINE
{
    ENG_NOTIFICATION_HEADER Header;         ///< Notification header.
    INTRO_PROCESS           Parent;         ///< The parent process that provided the command line.
    INTRO_PROCESS           Child;          ///< The child process that received the command line.
    BYTE *                  CmdLine;        ///< The command line to be scanned.
    DWORD                   CmdLineSize;    ///< The size of the command line buffer.
} ENG_NOTIFICATION_CMD_LINE, *PENG_NOTIFICATION_CMD_LINE;

//
// =====================================================================================================================
//


///
/// @brief  The state of an agent.
///
typedef enum
{
    agentInjected = 0,  ///< The agent has been successfully injected.
    agentInitialized,   ///< The agent has been initialized.
    agentStarted,       ///< The agent process started execution.
    agentTerminated,    ///< The agent process finished execution.
    agentMessage,       ///< The agent sent a message.
    agentError,         ///< The agent or the process stub reports an error.

    agentInvalid = -1   ///< Invalid.
} AGENT_EVENT_TYPE;


// Remediation tool hypercall (x64/x86):
//
// RAX/EAX = 34
// RDI/EBX = 24
// RSI/ECX = 0
// RDX/EDX = AGENT_HCALL_REM_TOOL
// RBX/ESI = pointer to a remediation structure
#define AGENT_HCALL_REM_TOOL        100     ///< Used by the remediation tool.

#define AGENT_HCALL_GATHER_TOOL     500     ///< Log gathering tool.

#define AGENT_HCALL_KILLER_TOOL     600     ///< Agent killer tool.

#define AGENT_HCALL_INTERNAL        753200  ///< Reserved for internal use.


//
// =====================================================================================================================
//

///
/// @brief  Remediation tool events types.
///
typedef enum
{
    remEventNone = 0,       ///< No event.
    remEventStart,          ///< Start event.
    remEventDetection,      ///< Detection event.
    remEventDisinfection,   ///< Disinfection event.
    remEventProgress,       ///< Progress report event.
    remEventReboot,         ///< Reboot event.
    remEventFinish          ///< Stop event.
} AGENT_REM_EVENT_TYPE;

/// The maximum object path size in bytes, including the NULL terminator.
#define REM_MAX_OBJECT_PATH_LEN     512
/// The maximum detection name size in bytes, including the NULL terminator.
#define REM_MAX_DETECTION_LEN       128

/// Remediation event version.
#define REM_EVENT_VERSION           0x00010000
/// Remediation event size.
#define REM_EVENT_SIZE              sizeof(AGENT_REM_EVENT)


///
/// @brief  Common header for all remediation tool events.
///
typedef struct _AGENT_REM_EVENT_HEADER
{
    DWORD                   Version;    ///< Event version. Must match #REM_EVENT_VERSION.
    DWORD                   Size;       ///< Event size. Must match #REM_EVENT_SIZE.
    DWORD                   Reserved;   ///< Reserved for padding/future use.
    AGENT_REM_EVENT_TYPE    EventType;  ///< Event type.
} AGENT_REM_EVENT_HEADER, *PAGENT_REM_EVENT_HEADER;

///
/// @brief  A remediation tool event.
///
/// Events of these type are sent when the remediation tool has been injected and started inside the guest and it is
/// executing intro calls (VMCALLs), reporting back to Introcore.
///
typedef struct _AGENT_REM_EVENT
{
    AGENT_REM_EVENT_HEADER Header;  ///< Event header.

    union
    {
        /// Start event. Valid if Header.EventType is #remEventStart.
        struct
        {
            DWORD       ScanStatus; ///< Start status.
        } StartEvent;

        /// Finish event. Valid if Header.EventType is #remEventFinish.
        struct
        {
            DWORD       ScanResult;     ///< Scan result.
        } FinishEvent;

        /// Progress event. Valid if Header.EventType is #remEventProgress.
        struct
        {
            DWORD       Progress;       ///< Progress.
        } ProgressEvent;

        /// Reboot event. Valid if Header.EventType is #remEventReboot.
        struct
        {
            BOOLEAN     RebootNeeded;   ///< TRUE if a reboot is needed.
        } RebootEvent;

        /// Detection event. Valid if Header.EventType is #remEventDetection.
        struct
        {
            /// Path of the scanned object.
            WCHAR       ObjectPath[REM_MAX_OBJECT_PATH_LEN];
            /// Detection name.
            WCHAR       Detection[REM_MAX_DETECTION_LEN];
            /// Detection flags.
            DWORD       DetectionFlag;
            /// Action result.
            DWORD       ActionResult;
        } DetectionEvent;

        /// Disinfection event. Valid if Header.EventType is #remEventDisinfection.
        struct
        {
            /// Path of the scanned object.
            WCHAR       ObjectPath[REM_MAX_OBJECT_PATH_LEN];
            /// Detection name.
            WCHAR       Detection[REM_MAX_DETECTION_LEN];
            /// Detection flags.
            DWORD       DetectionFlag;
            /// Action result.
            DWORD       ActionResult;
        } DisinfectionEvent;
    };
} AGENT_REM_EVENT, *PAGENT_REM_EVENT;


//
// =====================================================================================================================
//

///
/// @brief  Log gather tool events.
///
typedef enum
{
    lgtEventNone = 0,   ///< No event.
    lgtEventError,      ///< Error event.
    lgtEventData        ///< Data gather event.
} AGENT_LGT_EVENT_TYPE;

/// The maximum size of a log gather tool data chunk.
#define LGT_MAX_DATA_SIZE           4096

/// Log gather agent event version.
#define LGT_EVENT_VERSION           0x00010000
/// Log gather agent event size.
#define LGT_EVENT_SIZE              sizeof(AGENT_LGT_EVENT)

///
/// @brief  Common header for all log gather tool events.
///
/// Events of these type are sent when the log gathering tool has been injected and started inside the guest and it is
/// executing intro calls (VMCALLs), reporting back to Introcore.
///
typedef struct _AGENT_LGT_EVENT_HEADER
{
    DWORD               Version;    ///< Event version. Should match #LGT_EVENT_VERSION.
    DWORD               Size;       ///< Event size. Should match #LGT_EVENT_SIZE/
    DWORD               Reserved1;  ///< Reserved for padding/future use.
    DWORD               EventType;  ///< Event type.
} AGENT_LGT_EVENT_HEADER, *PAGENT_LGT_EVENT_HEADER;

///
/// @brief  Describes an event sent by the log gathering tool.
///
/// These will contain raw log lines.
///
typedef struct _AGENT_LGT_EVENT
{
    AGENT_LGT_EVENT_HEADER  Header; ///< Event header.

    union
    {
        /// @brief  Collected data.
        ///
        /// Valid only if Header.Type is #lgtEventData Multiple events of this type will be sent, in successive order,
        /// for each data chunk in all the files that should be gathered
        struct
        {
            /// The name of the file from which Data was obtained.
            WCHAR                   FileName[REM_MAX_OBJECT_PATH_LEN];
            /// Valid Data size.
            DWORD                   DataSize;
            /// Contents read from FileName.
            BYTE                    Data[LGT_MAX_DATA_SIZE];
        } DataEvent;

        /// @brief  Error report.
        ///
        /// Valid only if Header.Type is #lgtEventError.
        /// This indicates that the tool could not obtain data from one of the files
        struct
        {
            /// The error code reported by the tool.
            DWORD                   ErrorCode;
        } ErrorEvent;
    };
} AGENT_LGT_EVENT, *PAGENT_LGT_EVENT;


//
// =====================================================================================================================
//

///
/// @brief  Deployable agents tags.
///
typedef enum
{
    /// Dummy agent used to demo the feature.
    INTRO_AGENT_TAG_DUMMY_TOOL  = 0,

    /// The remediation tool agent.
    INTRO_AGENT_TAG_REMEDIATION_TOOL = 1,

    /// The visibility tool used to extract information from inside the guest.
    INTRO_AGENT_TAG_VISIBILITY_TOOL = 2,

    /// The Linux version of the remediation tool.
    INTRO_AGENT_TAG_REMEDIATION_TOOL_LINUX = 3,

    /// The log gathering agent.
    INTRO_AGENT_TAG_LOG_GATHER_TOOL = 4,

    /// The process killer agent.
    INTRO_AGENT_TAG_AGENT_KILLER_TOOL = 5,

    /// The virtualization exception driver.
    INTRO_AGENT_TAG_VE_DRIVER = 10,

    /// The page table filtering agent.
    INTRO_AGENT_TAG_PT_DRIVER = 11,

    /// A custom tool.
    INTRO_AGENT_TAG_CUSTOM_TOOL = 100
} INTRO_DEP_AG_TAGS;

///
/// @brief  Event structure for agent injection and termination.
///
typedef struct _EVENT_AGENT_EVENT
{
    AGENT_EVENT_TYPE    Event;      ///< The type of the agent.
    DWORD               AgentTag;   ///< Unique agent tag. See #INTRO_DEP_AG_TAGS.
    DWORD               ErrorCode;  ///< The error code of the event. Success is 0.

    /// @brief  The agent process.
    ///
    /// Pid, Cr3 and ImageName are not valid for #agentInjected and #agentTerminated events, as there is no active
    /// agent process in those phases.
    INTRO_PROCESS       CurrentProcess;

    /// @brief  State/agent specific information.
    ///
    /// Fields must be used depending on the AgentTag and are invalid if Event is not #agentMessage.
    union
    {
        /// @brief  Remediation tool event.
        ///
        /// Valid only if AgentTag is #INTRO_AGENT_TAG_REMEDIATION_TOOL or #INTRO_AGENT_TAG_REMEDIATION_TOOL_LINUX.
        AGENT_REM_EVENT RemediationEvent;
        /// @brief  Log gather tool event.
        ///
        /// Valid only if AgentTag is #INTRO_AGENT_TAG_LOG_GATHER_TOOL.
        AGENT_LGT_EVENT LogGatherEvent;
    };
} EVENT_AGENT_EVENT, *PEVENT_AGENT_EVENT;


///
/// @brief  Guest information.
///
typedef struct _GUEST_INFO
{
    INTRO_GUEST_TYPE    Type;           ///< Type.
    QWORD               BuildNumber;    ///< Build number.
    /// True if the OS is in 64-bit mode, False if it is not.
    BOOLEAN             Guest64;

    DWORD               OsVersion;      ///< Version.
    /// @brief  Startup time.
    ///
    /// Valid only if Type is #introGuestWindows.
    QWORD               StartupTime;

    QWORD               _Reserved[4];
} GUEST_INFO, *PGUEST_INFO;

///
/// @brief  Introspection version info.
///
typedef union _INT_VERSION_INFO
{
    /// @brief  Structured version information.
    struct
    {
        WORD        Build;      ///< Build number.
        WORD        Revision;   ///< Revision.
        WORD        Minor;      ///< Minor version.
        WORD        Major;      ///< Major version.
    } VersionInfo;

    QWORD           Raw;        ///< Raw version information.
} INT_VERSION_INFO, *PINT_VERSION_INFO;

///
/// @brief  The context of an error state.
///
/// This is optionally supplied to #GLUE_IFACE.NotifyIntrospectionErrorState calls for certain error classes.
///
typedef union _INTRO_ERROR_CONTEXT
{
    /// @brief  Process protection errors.
    ///
    /// Valid only when the reported error state is #intErrProcNotProtectedNoMemory or
    /// #intErrProcNotProtectedInternalError.
    struct
    {
        INTRO_PROCESS   Process;    ///< The process that could not be protected.
        DWORD           Count;      ///< The number of currently protected processes.
    } ProcessProtection;
} INTRO_ERROR_CONTEXT, *PINTRO_ERROR_CONTEXT;

///
/// @brief  Error states.
///
/// These are reported by #GLUE_IFACE.NotifyIntrospectionErrorState.
///
typedef enum
{
    intErrNone = 0,                         ///< Success.
    intErrGuestNotIdentified,               ///< The SYSCALL/SYSENTER code pattern was not recognized.
    intErrGuestNotSupported,                ///< The operating system version is not supported.
    intErrGuestKernelNotFound,              ///< The kernel image was not found.
    intErrGuestApiNotFound,                 ///< A critical API function was not found inside the guest kernel.
    intErrGuestExportNotFound,              ///< A kernel export was not found.
    intErrGuestStructureNotFound,           ///< A critical structure was not found inside the guest kernel.
    intErrUpdateFileNotSupported,           ///< The version of the provided CAMI file is not supported.
    
    /// @brief  The process was not protected because there is not enough memory available.
    intErrProcNotProtectedNoMemory,
    intErrProcNotProtectedInternalError,    ///< The process was not protected due to an internal error.
} INTRO_ERROR_STATE;

#pragma pack(pop)

#endif // _INTRO_TYPES_H_
